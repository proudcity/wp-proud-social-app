// Generated by CoffeeScript 1.10.0
(function(){"use strict";var _containersControllers,_windowEventsHandlerBinded,_windowInViewItems,addWindowInViewItem,angularInviewModule,bindWindowEvents,checkInView,debounce,getBoundingClientRect,getOffsetFromPercentage,getViewportHeight,offsetIsPercentage,removeWindowInViewItem,trackInViewContainer,triggerInViewCallback,unbindWindowEvents,untrackInViewContainer,windowCheckInView,windowEventsHandler,slice=[].slice;angularInviewModule=angular.module("angular-inview",[]).directive("inView",["$parse",function($parse){return{restrict:"A",require:"?^inViewContainer",link:function(scope,element,attrs,containerController){var inViewFunc,item,options,performCheck,ref,ref1;if(attrs.inView)return inViewFunc=$parse(attrs.inView),item={element:element,wasInView:!1,offset:0,customDebouncedCheck:null,callback:function($event,$inview,$inviewpart){return null==$event&&($event={}),scope.$evalAsync(function(_this){return function(){return $event.inViewTarget=element[0],inViewFunc(scope,{$event:$event,$inview:$inview,$inviewpart:$inviewpart})}}(this))}},null!=attrs.inViewOptions&&(options=scope.$eval(attrs.inViewOptions))&&(item.offset=options.offset||[options.offsetTop||0,options.offsetBottom||0],options.debounce&&(item.customDebouncedCheck=debounce(function(event){return checkInView([item],element[0],event)},options.debounce))),performCheck=null!=(ref=null!=(ref1=item.customDebouncedCheck)?ref1:null!=containerController?containerController.checkInView:void 0)?ref:windowCheckInView,null!=containerController?containerController.addItem(item):addWindowInViewItem(item),setTimeout(performCheck),scope.$on("$destroy",function(){return null!=containerController&&containerController.removeItem(item),removeWindowInViewItem(item)})}}}]).directive("inViewContainer",function(){return{restrict:"AC",controller:["$element",function($element){return this.items=[],this.addItem=function(item){return this.items.push(item)},this.removeItem=function(item){var i;return this.items=function(){var j,len,ref,results;for(ref=this.items,results=[],j=0,len=ref.length;len>j;j++)i=ref[j],i!==item&&results.push(i);return results}.call(this)},this.checkInView=function(_this){return function(event){var i,j,len,ref;for(ref=_this.items,j=0,len=ref.length;len>j;j++)i=ref[j],null!=i.customDebouncedCheck&&i.customDebouncedCheck();return checkInView(function(){var k,len1,ref1,results;for(ref1=this.items,results=[],k=0,len1=ref1.length;len1>k;k++)i=ref1[k],null==i.customDebouncedCheck&&results.push(i);return results}.call(_this),$element[0],event)}}(this),this}],link:function(scope,element,attrs,controller){return element.bind("scroll",controller.checkInView),trackInViewContainer(controller),scope.$on("$destroy",function(){return element.unbind("scroll",controller.checkInView),untrackInViewContainer(controller)})}}}),_windowInViewItems=[],addWindowInViewItem=function(item){return _windowInViewItems.push(item),bindWindowEvents()},removeWindowInViewItem=function(item){var i;return _windowInViewItems=function(){var j,len,results;for(results=[],j=0,len=_windowInViewItems.length;len>j;j++)i=_windowInViewItems[j],i!==item&&results.push(i);return results}(),unbindWindowEvents()},_containersControllers=[],trackInViewContainer=function(controller){return _containersControllers.push(controller),bindWindowEvents()},untrackInViewContainer=function(container){var c;return _containersControllers=function(){var j,len,results;for(results=[],j=0,len=_containersControllers.length;len>j;j++)c=_containersControllers[j],c!==container&&results.push(c);return results}(),unbindWindowEvents()},_windowEventsHandlerBinded=!1,windowEventsHandler=function(event){var c,j,len;for(j=0,len=_containersControllers.length;len>j;j++)c=_containersControllers[j],c.checkInView(event);return _windowInViewItems.length?windowCheckInView(event):void 0},bindWindowEvents=function(){return _windowEventsHandlerBinded?void 0:(_windowEventsHandlerBinded=!0,angular.element(window).bind("checkInView click ready scroll resize",windowEventsHandler))},unbindWindowEvents=function(){return!_windowEventsHandlerBinded||_windowInViewItems.length||_containersControllers.length?void 0:(_windowEventsHandlerBinded=!1,angular.element(window).unbind("checkInView click ready scroll resize",windowEventsHandler))},triggerInViewCallback=function(event,item,inview,isTopVisible,isBottomVisible){var elOffsetTop,inviewpart;if(inview){if(elOffsetTop=getBoundingClientRect(item.element[0]).top+window.pageYOffset,inviewpart=isTopVisible&&isBottomVisible&&"neither"||isTopVisible&&"top"||isBottomVisible&&"bottom"||"both",!item.wasInView||item.wasInView!==inviewpart||elOffsetTop!==item.lastOffsetTop)return item.lastOffsetTop=elOffsetTop,item.wasInView=inviewpart,item.callback(event,!0,inviewpart)}else if(item.wasInView)return item.wasInView=!1,item.callback(event,!1)},checkInView=function(items,container,event){var bounds,boundsBottom,boundsTop,element,item,j,k,len,len1,ref,ref1,ref2,ref3,results,viewport;if(viewport={top:0,bottom:getViewportHeight()},container&&container!==window){if(bounds=getBoundingClientRect(container),bounds.top>viewport.bottom||bounds.bottom<viewport.top){for(j=0,len=items.length;len>j;j++)item=items[j],triggerInViewCallback(event,item,!1);return}bounds.top>viewport.top&&(viewport.top=bounds.top),bounds.bottom<viewport.bottom&&(viewport.bottom=bounds.bottom)}for(results=[],k=0,len1=items.length;len1>k;k++)item=items[k],element=item.element[0],bounds=getBoundingClientRect(element),boundsTop=bounds.top+(offsetIsPercentage(item.offset)?getOffsetFromPercentage(bounds,item.offset):parseInt(null!=(ref=null!=(ref1=item.offset)?ref1[0]:void 0)?ref:item.offset)),boundsBottom=bounds.bottom+(offsetIsPercentage(item.offset)?getOffsetFromPercentage(bounds,item.offset):parseInt(null!=(ref2=null!=(ref3=item.offset)?ref3[1]:void 0)?ref2:item.offset)),boundsTop<viewport.bottom&&boundsBottom>=viewport.top?results.push(triggerInViewCallback(event,item,!0,boundsBottom>viewport.bottom,boundsTop<viewport.top)):results.push(triggerInViewCallback(event,item,!1));return results},offsetIsPercentage=function(offset){return"string"==typeof offset&&"%"===offset.slice(-1)},getOffsetFromPercentage=function(bounds,offsetPercentage){var percentage;return percentage=offsetPercentage.substring(0,offsetPercentage.length-1),(bounds.bottom-bounds.top)*(percentage/100)},getViewportHeight=function(){var height,mode,ref;return(height=window.innerHeight)?height:(mode=document.compatMode,(mode||!("undefined"!=typeof $&&null!==$&&null!=(ref=$.support)?ref.boxModel:void 0))&&(height="CSS1Compat"===mode?document.documentElement.clientHeight:document.body.clientHeight),height)},getBoundingClientRect=function(element){var el,parent,top;if(null!=element.getBoundingClientRect)return element.getBoundingClientRect();for(top=0,el=element;el;)top+=el.offsetTop,el=el.offsetParent;for(parent=element.parentElement;parent;)null!=parent.scrollTop&&(top-=parent.scrollTop),parent=parent.parentElement;return{top:top,bottom:top+element.offsetHeight}},debounce=function(f,t){var timer;return timer=null,function(){var args;return args=1<=arguments.length?slice.call(arguments,0):[],null!=timer&&clearTimeout(timer),timer=setTimeout(function(){return f.apply(null,args)},null!=t?t:100)}},windowCheckInView=function(event){var i,j,len;for(j=0,len=_windowInViewItems.length;len>j;j++)i=_windowInViewItems[j],null!=i.customDebouncedCheck&&i.customDebouncedCheck();return checkInView(function(){var k,len1,results;for(results=[],k=0,len1=_windowInViewItems.length;len1>k;k++)i=_windowInViewItems[k],null==i.customDebouncedCheck&&results.push(i);return results}(),null,event)},"function"==typeof define&&define.amd?define(["angular"],angularInviewModule):"undefined"!=typeof module&&module&&module.exports&&(module.exports=angularInviewModule)}).call(this),angular.module("angular-lazycompile",[]).directive("lazyCompile",["$compile",function($compile){return{scope:{lazyCompile:"=",lazyDecode:"="},replace:!0,link:function(scope,element,attrs){var voidCompile=scope.$watch("lazyCompile",function(value){if(value&&"false"!=value){scope.lazyDecode&&(value=decodeURIComponent(value));
// when the 'compile' expression changes
var lazyContent=angular.element(value);
// Add after our element
element.after(lazyContent),
// compile the new DOM
$compile(lazyContent)(scope.$parent),setTimeout(function(){scope.$destroy(),scope=null,element.remove(),element=null},0),
// Use un-watch feature to ensure compilation happens only once.
voidCompile()}})}}}]),function(){"use strict";/**
     * Class for managing events.
     * Can be extended to provide event functionality in other classes.
     *
     * @class EventEmitter Manages event registering and emitting.
     */
function EventEmitter(){}/**
     * Finds the index of the listener for the event in its storage array.
     *
     * @param {Function[]} listeners Array of listeners to search through.
     * @param {Function} listener Method to look for.
     * @return {Number} Index of the specified listener, -1 if not found
     * @api private
     */
function indexOfListener(listeners,listener){for(var i=listeners.length;i--;)if(listeners[i].listener===listener)return i;return-1}/**
     * Alias a method while keeping the context correct, to allow for overwriting of target method.
     *
     * @param {String} name The name of the target method.
     * @return {Function} The aliased method
     * @api private
     */
function alias(name){return function(){return this[name].apply(this,arguments)}}
// Shortcuts to improve speed and size
var proto=EventEmitter.prototype,exports=this,originalGlobalValue=exports.EventEmitter;/**
     * Returns the listener array for the specified event.
     * Will initialise the event object and listener arrays if required.
     * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
     * Each property in the object response is an array of listener functions.
     *
     * @param {String|RegExp} evt Name of the event to return the listeners from.
     * @return {Function[]|Object} All listener functions for the event.
     */
proto.getListeners=function(evt){var response,key,events=this._getEvents();
// Return a concatenated array of all matching events if
// the selector is a regular expression.
if(evt instanceof RegExp){response={};for(key in events)events.hasOwnProperty(key)&&evt.test(key)&&(response[key]=events[key])}else response=events[evt]||(events[evt]=[]);return response},/**
     * Takes a list of listener objects and flattens it into a list of listener functions.
     *
     * @param {Object[]} listeners Raw listener objects.
     * @return {Function[]} Just the listener functions.
     */
proto.flattenListeners=function(listeners){var i,flatListeners=[];for(i=0;i<listeners.length;i+=1)flatListeners.push(listeners[i].listener);return flatListeners},/**
     * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
     *
     * @param {String|RegExp} evt Name of the event to return the listeners from.
     * @return {Object} All listener functions for an event in an object.
     */
proto.getListenersAsObject=function(evt){var response,listeners=this.getListeners(evt);return listeners instanceof Array&&(response={},response[evt]=listeners),response||listeners},/**
     * Adds a listener function to the specified event.
     * The listener will not be added if it is a duplicate.
     * If the listener returns true then it will be removed after it is called.
     * If you pass a regular expression as the event name then the listener will be added to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to attach the listener to.
     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
proto.addListener=function(evt,listener){var key,listeners=this.getListenersAsObject(evt),listenerIsWrapped="object"==typeof listener;for(key in listeners)listeners.hasOwnProperty(key)&&-1===indexOfListener(listeners[key],listener)&&listeners[key].push(listenerIsWrapped?listener:{listener:listener,once:!1});return this},/**
     * Alias of addListener
     */
proto.on=alias("addListener"),/**
     * Semi-alias of addListener. It will add a listener that will be
     * automatically removed after its first execution.
     *
     * @param {String|RegExp} evt Name of the event to attach the listener to.
     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
proto.addOnceListener=function(evt,listener){return this.addListener(evt,{listener:listener,once:!0})},/**
     * Alias of addOnceListener.
     */
proto.once=alias("addOnceListener"),/**
     * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
     * You need to tell it what event names should be matched by a regex.
     *
     * @param {String} evt Name of the event to create.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
proto.defineEvent=function(evt){return this.getListeners(evt),this},/**
     * Uses defineEvent to define multiple events.
     *
     * @param {String[]} evts An array of event names to define.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
proto.defineEvents=function(evts){for(var i=0;i<evts.length;i+=1)this.defineEvent(evts[i]);return this},/**
     * Removes a listener function from the specified event.
     * When passed a regular expression as the event name, it will remove the listener from all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to remove the listener from.
     * @param {Function} listener Method to remove from the event.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
proto.removeListener=function(evt,listener){var index,key,listeners=this.getListenersAsObject(evt);for(key in listeners)listeners.hasOwnProperty(key)&&(index=indexOfListener(listeners[key],listener),-1!==index&&listeners[key].splice(index,1));return this},/**
     * Alias of removeListener
     */
proto.off=alias("removeListener"),/**
     * Adds listeners in bulk using the manipulateListeners method.
     * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
     * You can also pass it a regular expression to add the array of listeners to all events that match it.
     * Yeah, this function does quite a bit. That's probably a bad thing.
     *
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to add.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
proto.addListeners=function(evt,listeners){
// Pass through to manipulateListeners
return this.manipulateListeners(!1,evt,listeners)},/**
     * Removes listeners in bulk using the manipulateListeners method.
     * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
     * You can also pass it an event name and an array of listeners to be removed.
     * You can also pass it a regular expression to remove the listeners from all events that match it.
     *
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to remove.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
proto.removeListeners=function(evt,listeners){
// Pass through to manipulateListeners
return this.manipulateListeners(!0,evt,listeners)},/**
     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
     * The first argument will determine if the listeners are removed (true) or added (false).
     * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
     * You can also pass it an event name and an array of listeners to be added/removed.
     * You can also pass it a regular expression to manipulate the listeners of all events that match it.
     *
     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
proto.manipulateListeners=function(remove,evt,listeners){var i,value,single=remove?this.removeListener:this.addListener,multiple=remove?this.removeListeners:this.addListeners;
// If evt is an object then pass each of its properties to this method
if("object"!=typeof evt||evt instanceof RegExp)for(
// So evt must be a string
// And listeners must be an array of listeners
// Loop over it and pass each one to the multiple method
i=listeners.length;i--;)single.call(this,evt,listeners[i]);else for(i in evt)evt.hasOwnProperty(i)&&(value=evt[i])&&(
// Pass the single listener straight through to the singular method
"function"==typeof value?single.call(this,i,value):
// Otherwise pass back to the multiple function
multiple.call(this,i,value));return this},/**
     * Removes all listeners from a specified event.
     * If you do not specify an event then all listeners will be removed.
     * That means every event will be emptied.
     * You can also pass a regex to remove all events that match it.
     *
     * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
proto.removeEvent=function(evt){var key,type=typeof evt,events=this._getEvents();
// Remove different things depending on the state of evt
if("string"===type)
// Remove all listeners for the specified event
delete events[evt];else if(evt instanceof RegExp)
// Remove all events matching the regex.
for(key in events)events.hasOwnProperty(key)&&evt.test(key)&&delete events[key];else
// Remove all listeners in all events
delete this._events;return this},/**
     * Alias of removeEvent.
     *
     * Added to mirror the node API.
     */
proto.removeAllListeners=alias("removeEvent"),/**
     * Emits an event of your choice.
     * When emitted, every listener attached to that event will be executed.
     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
     * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
     * So they will not arrive within the array on the other side, they will be separate.
     * You can also pass a regular expression to emit to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
     * @param {Array} [args] Optional array of arguments to be passed to each listener.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
proto.emitEvent=function(evt,args){var listeners,listener,i,key,response,listenersMap=this.getListenersAsObject(evt);for(key in listenersMap)if(listenersMap.hasOwnProperty(key))for(listeners=listenersMap[key].slice(0),i=listeners.length;i--;)listener=listeners[i],listener.once===!0&&this.removeListener(evt,listener.listener),response=listener.listener.apply(this,args||[]),response===this._getOnceReturnValue()&&this.removeListener(evt,listener.listener);return this},/**
     * Alias of emitEvent
     */
proto.trigger=alias("emitEvent"),/**
     * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
     * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
     * @param {...*} Optional additional arguments to be passed to each listener.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
proto.emit=function(evt){var args=Array.prototype.slice.call(arguments,1);return this.emitEvent(evt,args)},/**
     * Sets the current value to check against when executing listeners. If a
     * listeners return value matches the one set here then it will be removed
     * after execution. This value defaults to true.
     *
     * @param {*} value The new value to check for when executing listeners.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
proto.setOnceReturnValue=function(value){return this._onceReturnValue=value,this},/**
     * Fetches the current value to check against when executing listeners. If
     * the listeners return value matches this one then it should be removed
     * automatically. It will return true by default.
     *
     * @return {*|Boolean} The current value to check for or the default, true.
     * @api private
     */
proto._getOnceReturnValue=function(){return this.hasOwnProperty("_onceReturnValue")?this._onceReturnValue:!0},/**
     * Fetches the events object and creates one if required.
     *
     * @return {Object} The events storage object.
     * @api private
     */
proto._getEvents=function(){return this._events||(this._events={})},/**
     * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
     *
     * @return {Function} Non conflicting EventEmitter class.
     */
EventEmitter.noConflict=function(){return exports.EventEmitter=originalGlobalValue,EventEmitter},
// Expose the class either via AMD, CommonJS or the global object
"function"==typeof define&&define.amd?define(function(){return EventEmitter}):"object"==typeof module&&module.exports?module.exports=EventEmitter:exports.EventEmitter=EventEmitter}.call(this),/*!
 * eventie v1.0.6
 * event binding helper
 *   eventie.bind( elem, 'click', myFn )
 *   eventie.unbind( elem, 'click', myFn )
 * MIT license
 */
/*jshint browser: true, undef: true, unused: true */
/*global define: false, module: false */
function(window){"use strict";function getIEEvent(obj){var event=window.event;
// add event.target
return event.target=event.target||event.srcElement||obj,event}var docElem=document.documentElement,bind=function(){};docElem.addEventListener?bind=function(obj,type,fn){obj.addEventListener(type,fn,!1)}:docElem.attachEvent&&(bind=function(obj,type,fn){obj[type+fn]=fn.handleEvent?function(){var event=getIEEvent(obj);fn.handleEvent.call(fn,event)}:function(){var event=getIEEvent(obj);fn.call(obj,event)},obj.attachEvent("on"+type,obj[type+fn])});var unbind=function(){};docElem.removeEventListener?unbind=function(obj,type,fn){obj.removeEventListener(type,fn,!1)}:docElem.detachEvent&&(unbind=function(obj,type,fn){obj.detachEvent("on"+type,obj[type+fn]);try{delete obj[type+fn]}catch(err){
// can't delete window object properties
obj[type+fn]=void 0}});var eventie={bind:bind,unbind:unbind};
// ----- module definition ----- //
"function"==typeof define&&define.amd?
// AMD
define(eventie):"object"==typeof exports?module.exports=eventie:window.eventie=eventie}(window),/*!
 * imagesLoaded v3.1.8
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */
function(window,factory){"use strict";
// universal module definition
/*global define: false, module: false, require: false */
"function"==typeof define&&define.amd?
// AMD
define(["eventEmitter/EventEmitter","eventie/eventie"],function(EventEmitter,eventie){return factory(window,EventEmitter,eventie)}):"object"==typeof exports?module.exports=factory(window,require("wolfy87-eventemitter"),require("eventie")):window.imagesLoaded=factory(window,window.EventEmitter,window.eventie)}(window,
// --------------------------  factory -------------------------- //
function(window,EventEmitter,eventie){"use strict";
// -------------------------- helpers -------------------------- //
// extend objects
function extend(a,b){for(var prop in b)a[prop]=b[prop];return a}function isArray(obj){return"[object Array]"===objToString.call(obj)}
// turn element or nodeList into an array
function makeArray(obj){var ary=[];if(isArray(obj))
// use object if already an array
ary=obj;else if("number"==typeof obj.length)
// convert nodeList to array
for(var i=0,len=obj.length;len>i;i++)ary.push(obj[i]);else
// array of single index
ary.push(obj);return ary}
// -------------------------- imagesLoaded -------------------------- //
/**
   * @param {Array, Element, NodeList, String} elem
   * @param {Object or Function} options - if function, use as callback
   * @param {Function} onAlways - callback function
   */
function ImagesLoaded(elem,options,onAlways){
// coerce ImagesLoaded() without new, to be new ImagesLoaded()
if(!(this instanceof ImagesLoaded))return new ImagesLoaded(elem,options);
// use elem as selector string
"string"==typeof elem&&(elem=document.querySelectorAll(elem)),this.elements=makeArray(elem),this.options=extend({},this.options),"function"==typeof options?onAlways=options:extend(this.options,options),onAlways&&this.on("always",onAlways),this.getImages(),$&&(
// add jQuery Deferred object
this.jqDeferred=new $.Deferred);
// HACK check async to allow time to bind listeners
var _this=this;setTimeout(function(){_this.check()})}
// --------------------------  -------------------------- //
function LoadingImage(img){this.img=img}function Resource(src){this.src=src,
// add to cache
cache[src]=this}var $=window.jQuery,console=window.console,hasConsole="undefined"!=typeof console,objToString=Object.prototype.toString;ImagesLoaded.prototype=new EventEmitter,ImagesLoaded.prototype.options={},ImagesLoaded.prototype.getImages=function(){this.images=[];
// filter & find items if we have an item selector
for(var i=0,len=this.elements.length;len>i;i++){var elem=this.elements[i];
// filter siblings
"IMG"===elem.nodeName&&this.addImage(elem);
// find children
// no non-element nodes, #143
var nodeType=elem.nodeType;if(nodeType&&(1===nodeType||9===nodeType||11===nodeType))
// concat childElems to filterFound array
for(var childElems=elem.querySelectorAll("img"),j=0,jLen=childElems.length;jLen>j;j++){var img=childElems[j];this.addImage(img)}}},/**
   * @param {Image} img
   */
ImagesLoaded.prototype.addImage=function(img){var loadingImage=new LoadingImage(img);this.images.push(loadingImage)},ImagesLoaded.prototype.check=function(){function onConfirm(image,message){return _this.options.debug&&hasConsole&&console.log("confirm",image,message),_this.progress(image),checkedCount++,checkedCount===length&&_this.complete(),!0}var _this=this,checkedCount=0,length=this.images.length;
// complete if no images
if(this.hasAnyBroken=!1,!length)return void this.complete();for(var i=0;length>i;i++){var loadingImage=this.images[i];loadingImage.on("confirm",onConfirm),loadingImage.check()}},ImagesLoaded.prototype.progress=function(image){this.hasAnyBroken=this.hasAnyBroken||!image.isLoaded;
// HACK - Chrome triggers event before object properties have changed. #83
var _this=this;setTimeout(function(){_this.emit("progress",_this,image),_this.jqDeferred&&_this.jqDeferred.notify&&_this.jqDeferred.notify(_this,image)})},ImagesLoaded.prototype.complete=function(){var eventName=this.hasAnyBroken?"fail":"done";this.isComplete=!0;var _this=this;
// HACK - another setTimeout so that confirm happens after progress
setTimeout(function(){if(_this.emit(eventName,_this),_this.emit("always",_this),_this.jqDeferred){var jqMethod=_this.hasAnyBroken?"reject":"resolve";_this.jqDeferred[jqMethod](_this)}})},
// -------------------------- jquery -------------------------- //
$&&($.fn.imagesLoaded=function(options,callback){var instance=new ImagesLoaded(this,options,callback);return instance.jqDeferred.promise($(this))}),LoadingImage.prototype=new EventEmitter,LoadingImage.prototype.check=function(){
// first check cached any previous images that have same src
var resource=cache[this.img.src]||new Resource(this.img.src);if(resource.isConfirmed)return void this.confirm(resource.isLoaded,"cached was confirmed");
// If complete is true and browser supports natural sizes,
// try to check for image status manually.
if(this.img.complete&&void 0!==this.img.naturalWidth)
// report based on naturalWidth
return void this.confirm(0!==this.img.naturalWidth,"naturalWidth");
// If none of the checks above matched, simulate loading on detached element.
var _this=this;resource.on("confirm",function(resrc,message){return _this.confirm(resrc.isLoaded,message),!0}),resource.check()},LoadingImage.prototype.confirm=function(isLoaded,message){this.isLoaded=isLoaded,this.emit("confirm",this,message)};
// -------------------------- Resource -------------------------- //
// Resource checks each src, only once
// separate class from LoadingImage to prevent memory leaks. See #115
var cache={};
// -----  ----- //
// ----- events ----- //
// trigger specified handler for event type
// ----- confirm ----- //
return Resource.prototype=new EventEmitter,Resource.prototype.check=function(){
// only trigger checking once
if(!this.isChecked){
// simulate loading on detached element
var proxyImage=new Image;eventie.bind(proxyImage,"load",this),eventie.bind(proxyImage,"error",this),proxyImage.src=this.src,
// set flag
this.isChecked=!0}},Resource.prototype.handleEvent=function(event){var method="on"+event.type;this[method]&&this[method](event)},Resource.prototype.onload=function(event){this.confirm(!0,"onload"),this.unbindProxyEvents(event)},Resource.prototype.onerror=function(event){this.confirm(!1,"onerror"),this.unbindProxyEvents(event)},Resource.prototype.confirm=function(isLoaded,message){this.isConfirmed=!0,this.isLoaded=isLoaded,this.emit("confirm",this,message)},Resource.prototype.unbindProxyEvents=function(event){eventie.unbind(event.target,"load",this),eventie.unbind(event.target,"error",this)},ImagesLoaded});/**
 * Created by Joyce Cam on 30/12/2014.
 * Edited by Melvin Valster to temp-fix the ellipsis problem.
 * 
 * Simple and easy-to-implement angular read more directive.
 *
 */
var readMore=angular.module("readMore",[]);readMore.directive("readMore",function(){return{restrict:"A",transclude:!0,replace:!0,template:"<p></p>",scope:{moreText:"@",lessText:"@",words:"@",ellipsis:"@","char":"@",limit:"@",content:"@",moreCallback:"&",lessCallback:"&"},link:function(scope,elem,attr,ctrl,transclude){
// transclude(scope.$parent, function (clone, scope) {
//     readmore(clone.text().trim());
// });
function splitIntoWords(div){function removeEmptyStrings(k){return""!==k}for(var rWordBoundary=/[\s\n\t]+/,output=[],i=0;i<div.childNodes.length;++i){// Iterate through all nodes
var node=div.childNodes[i];if(node.nodeType===Node.TEXT_NODE){// The child is a text node
var words=node.nodeValue.split(rWordBoundary).filter(removeEmptyStrings);words.length&&output.push.apply(output,words)}else node.nodeType===Node.COMMENT_NODE||output.push(node.outerHTML)}return output}function readmore(text){var text=text,orig=text,regex=/\s+/gi,charCount=text.length,wordCount=text.trim().replace(regex," ").split(" ").length,countBy="char",count=charCount,foundWords=[],markup=text,more="";if(angular.isUndefined(attr.words)||(countBy="words",count=wordCount),"words"===countBy){// Count words
//http://stackoverflow.com/a/26833172/1327637
var span=document.createElement("span");span.innerHTML=text,foundWords=splitIntoWords(span),foundWords.length>limit&&(text=foundWords.slice(0,limit).join(" ")+ellipsis,more=foundWords.slice(limit,count).join(" "),markup=text+moreText+'<span class="more-text">'+more+lessText+"</span>")}else// Count characters
count>limit&&(text=orig.slice(0,limit)+ellipsis,more=orig.slice(limit,count),markup=text+moreText+'<span class="more-text">'+more+lessText+"</span>");elem.append(markup),elem.find(".read-more").on("click",function(){return elem.find(".read-more").hide(),elem.find(".ellipsis").hide(),elem.find(".more-text").addClass("show").slideDown(),scope.moreCallback&&scope.moreCallback(),!1}),elem.find(".read-less").on("click",function(){return elem.find(".read-more").show(),elem.find(".ellipsis").show(),elem.find(".more-text").hide().removeClass("show"),scope.lessCallback&&scope.lessCallback(),!1})}var moreText=angular.isUndefined(scope.moreText)?' <a href="#" class="read-more">Read More...</a>':' <a class="read-more">'+scope.moreText+"</a>",lessText=angular.isUndefined(scope.lessText)?' <a href="#" class="read-less">Less ^</a>':' <a class="read-less">'+scope.lessText+"</a>",ellipsis=angular.isUndefined(scope.ellipsis)?"":'<span class="ellipsis">'+scope.ellipsis+"</span>",limit=angular.isUndefined(scope.limit)?150:scope.limit;attr.$observe("content",function(str){readmore(str)})}}}),/**
 * @license AngularJS v1.3.5
 * (c) 2010-2014 Google, Inc. http://angularjs.org
 * License: MIT
 */
function(window,angular,undefined){"use strict";/* jshint maxlen: false */
/**
 * @ngdoc module
 * @name ngAnimate
 * @description
 *
 * The `ngAnimate` module provides support for JavaScript, CSS3 transition and CSS3 keyframe animation hooks within existing core and custom directives.
 *
 * <div doc-module-components="ngAnimate"></div>
 *
 * # Usage
 *
 * To see animations in action, all that is required is to define the appropriate CSS classes
 * or to register a JavaScript animation via the myModule.animation() function. The directives that support animation automatically are:
 * `ngRepeat`, `ngInclude`, `ngIf`, `ngSwitch`, `ngShow`, `ngHide`, `ngView` and `ngClass`. Custom directives can take advantage of animation
 * by using the `$animate` service.
 *
 * Below is a more detailed breakdown of the supported animation events provided by pre-existing ng directives:
 *
 * | Directive                                                                                                | Supported Animations                                                     |
 * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|
 * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |
 * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |
 * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |
 * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |
 * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |
 * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |
 * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |
 * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |
 * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |
 * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |
 *
 * You can find out more information about animations upon visiting each directive page.
 *
 * Below is an example of how to apply animations to a directive that supports animation hooks:
 *
 * ```html
 * <style type="text/css">
 * .slide.ng-enter, .slide.ng-leave {
 *   -webkit-transition:0.5s linear all;
 *   transition:0.5s linear all;
 * }
 *
 * .slide.ng-enter { }        /&#42; starting animations for enter &#42;/
 * .slide.ng-enter.ng-enter-active { } /&#42; terminal animations for enter &#42;/
 * .slide.ng-leave { }        /&#42; starting animations for leave &#42;/
 * .slide.ng-leave.ng-leave-active { } /&#42; terminal animations for leave &#42;/
 * </style>
 *
 * <!--
 * the animate service will automatically add .ng-enter and .ng-leave to the element
 * to trigger the CSS transition/animations
 * -->
 * <ANY class="slide" ng-include="..."></ANY>
 * ```
 *
 * Keep in mind that, by default, if an animation is running, any child elements cannot be animated
 * until the parent element's animation has completed. This blocking feature can be overridden by
 * placing the `ng-animate-children` attribute on a parent container tag.
 *
 * ```html
 * <div class="slide-animation" ng-if="on" ng-animate-children>
 *   <div class="fade-animation" ng-if="on">
 *     <div class="explode-animation" ng-if="on">
 *        ...
 *     </div>
 *   </div>
 * </div>
 * ```
 *
 * When the `on` expression value changes and an animation is triggered then each of the elements within
 * will all animate without the block being applied to child elements.
 *
 * ## Are animations run when the application starts?
 * No they are not. When an application is bootstrapped Angular will disable animations from running to avoid
 * a frenzy of animations from being triggered as soon as the browser has rendered the screen. For this to work,
 * Angular will wait for two digest cycles until enabling animations. From there on, any animation-triggering
 * layout changes in the application will trigger animations as normal.
 *
 * In addition, upon bootstrap, if the routing system or any directives or load remote data (via $http) then Angular
 * will automatically extend the wait time to enable animations once **all** of the outbound HTTP requests
 * are complete.
 *
 * ## CSS-defined Animations
 * The animate service will automatically apply two CSS classes to the animated element and these two CSS classes
 * are designed to contain the start and end CSS styling. Both CSS transitions and keyframe animations are supported
 * and can be used to play along with this naming structure.
 *
 * The following code below demonstrates how to perform animations using **CSS transitions** with Angular:
 *
 * ```html
 * <style type="text/css">
 * /&#42;
 *  The animate class is apart of the element and the ng-enter class
 *  is attached to the element once the enter animation event is triggered
 * &#42;/
 * .reveal-animation.ng-enter {
 *  -webkit-transition: 1s linear all; /&#42; Safari/Chrome &#42;/
 *  transition: 1s linear all; /&#42; All other modern browsers and IE10+ &#42;/
 *
 *  /&#42; The animation preparation code &#42;/
 *  opacity: 0;
 * }
 *
 * /&#42;
 *  Keep in mind that you want to combine both CSS
 *  classes together to avoid any CSS-specificity
 *  conflicts
 * &#42;/
 * .reveal-animation.ng-enter.ng-enter-active {
 *  /&#42; The animation code itself &#42;/
 *  opacity: 1;
 * }
 * </style>
 *
 * <div class="view-container">
 *   <div ng-view class="reveal-animation"></div>
 * </div>
 * ```
 *
 * The following code below demonstrates how to perform animations using **CSS animations** with Angular:
 *
 * ```html
 * <style type="text/css">
 * .reveal-animation.ng-enter {
 *   -webkit-animation: enter_sequence 1s linear; /&#42; Safari/Chrome &#42;/
 *   animation: enter_sequence 1s linear; /&#42; IE10+ and Future Browsers &#42;/
 * }
 * @-webkit-keyframes enter_sequence {
 *   from { opacity:0; }
 *   to { opacity:1; }
 * }
 * @keyframes enter_sequence {
 *   from { opacity:0; }
 *   to { opacity:1; }
 * }
 * </style>
 *
 * <div class="view-container">
 *   <div ng-view class="reveal-animation"></div>
 * </div>
 * ```
 *
 * Both CSS3 animations and transitions can be used together and the animate service will figure out the correct duration and delay timing.
 *
 * Upon DOM mutation, the event class is added first (something like `ng-enter`), then the browser prepares itself to add
 * the active class (in this case `ng-enter-active`) which then triggers the animation. The animation module will automatically
 * detect the CSS code to determine when the animation ends. Once the animation is over then both CSS classes will be
 * removed from the DOM. If a browser does not support CSS transitions or CSS animations then the animation will start and end
 * immediately resulting in a DOM element that is at its final state. This final state is when the DOM element
 * has no CSS transition/animation classes applied to it.
 *
 * ### Structural transition animations
 *
 * Structural transitions (such as enter, leave and move) will always apply a `0s none` transition
 * value to force the browser into rendering the styles defined in the setup (.ng-enter, .ng-leave
 * or .ng-move) class. This means that any active transition animations operating on the element
 * will be cut off to make way for the enter, leave or move animation.
 *
 * ### Class-based transition animations
 *
 * Class-based transitions refer to transition animations that are triggered when a CSS class is
 * added to or removed from the element (via `$animate.addClass`, `$animate.removeClass`,
 * `$animate.setClass`, or by directives such as `ngClass`, `ngModel` and `form`).
 * They are different when compared to structural animations since they **do not cancel existing
 * animations** nor do they **block successive transitions** from rendering on the same element.
 * This distinction allows for **multiple class-based transitions** to be performed on the same element.
 *
 * In addition to ngAnimate supporting the default (natural) functionality of class-based transition
 * animations, ngAnimate also decorates the element with starting and ending CSS classes to aid the
 * developer in further styling the element throughout the transition animation. Earlier versions
 * of ngAnimate may have caused natural CSS transitions to break and not render properly due to
 * $animate temporarily blocking transitions using `0s none` in order to allow the setup CSS class
 * (the `-add` or `-remove` class) to be applied without triggering an animation. However, as of
 * **version 1.3**, this workaround has been removed with ngAnimate and all non-ngAnimate CSS
 * class transitions are compatible with ngAnimate.
 *
 * There is, however, one special case when dealing with class-based transitions in ngAnimate.
 * When rendering class-based transitions that make use of the setup and active CSS classes
 * (e.g. `.fade-add` and `.fade-add-active` for when `.fade` is added) be sure to define
 * the transition value **on the active CSS class** and not the setup class.
 *
 * ```css
 * .fade-add {
 *   /&#42; remember to place a 0s transition here
 *      to ensure that the styles are applied instantly
 *      even if the element already has a transition style &#42;/
 *   transition:0s linear all;
 *
 *   /&#42; starting CSS styles &#42;/
 *   opacity:1;
 * }
 * .fade-add.fade-add-active {
 *   /&#42; this will be the length of the animation &#42;/
 *   transition:1s linear all;
 *   opacity:0;
 * }
 * ```
 *
 * The setup CSS class (in this case `.fade-add`) also has a transition style property, however, it
 * has a duration of zero. This may not be required, however, incase the browser is unable to render
 * the styling present in this CSS class instantly then it could be that the browser is attempting
 * to perform an unnecessary transition.
 *
 * This workaround, however, does not apply to  standard class-based transitions that are rendered
 * when a CSS class containing a transition is applied to an element:
 *
 * ```css
 * /&#42; this works as expected &#42;/
 * .fade {
 *   transition:1s linear all;
 *   opacity:0;
 * }
 * ```
 *
 * Please keep this in mind when coding the CSS markup that will be used within class-based transitions.
 * Also, try not to mix the two class-based animation flavors together since the CSS code may become
 * overly complex.
 *
 *
 * ### Preventing Collisions With Third Party Libraries
 *
 * Some third-party frameworks place animation duration defaults across many element or className
 * selectors in order to make their code small and reuseable. This can lead to issues with ngAnimate, which
 * is expecting actual animations on these elements and has to wait for their completion.
 *
 * You can prevent this unwanted behavior by using a prefix on all your animation classes:
 *
 * ```css
 * /&#42; prefixed with animate- &#42;/
 * .animate-fade-add.animate-fade-add-active {
 *   transition:1s linear all;
 *   opacity:0;
 * }
 * ```
 *
 * You then configure `$animate` to enforce this prefix:
 *
 * ```js
 * $animateProvider.classNameFilter(/animate-/);
 * ```
 * </div>
 *
 * ### CSS Staggering Animations
 * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a
 * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be
 * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for
 * the animation. The style property expected within the stagger class can either be a **transition-delay** or an
 * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).
 *
 * ```css
 * .my-animation.ng-enter {
 *   /&#42; standard transition code &#42;/
 *   -webkit-transition: 1s linear all;
 *   transition: 1s linear all;
 *   opacity:0;
 * }
 * .my-animation.ng-enter-stagger {
 *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/
 *   -webkit-transition-delay: 0.1s;
 *   transition-delay: 0.1s;
 *
 *   /&#42; in case the stagger doesn't work then these two values
 *    must be set to 0 to avoid an accidental CSS inheritance &#42;/
 *   -webkit-transition-duration: 0s;
 *   transition-duration: 0s;
 * }
 * .my-animation.ng-enter.ng-enter-active {
 *   /&#42; standard transition styles &#42;/
 *   opacity:1;
 * }
 * ```
 *
 * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations
 * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this
 * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation
 * will also be reset if more than 10ms has passed after the last animation has been fired.
 *
 * The following code will issue the **ng-leave-stagger** event on the element provided:
 *
 * ```js
 * var kids = parent.children();
 *
 * $animate.leave(kids[0]); //stagger index=0
 * $animate.leave(kids[1]); //stagger index=1
 * $animate.leave(kids[2]); //stagger index=2
 * $animate.leave(kids[3]); //stagger index=3
 * $animate.leave(kids[4]); //stagger index=4
 *
 * $timeout(function() {
 *   //stagger has reset itself
 *   $animate.leave(kids[5]); //stagger index=0
 *   $animate.leave(kids[6]); //stagger index=1
 * }, 100, false);
 * ```
 *
 * Stagger animations are currently only supported within CSS-defined animations.
 *
 * ## JavaScript-defined Animations
 * In the event that you do not want to use CSS3 transitions or CSS3 animations or if you wish to offer animations on browsers that do not
 * yet support CSS transitions/animations, then you can make use of JavaScript animations defined inside of your AngularJS module.
 *
 * ```js
 * //!annotate="YourApp" Your AngularJS Module|Replace this or ngModule with the module that you used to define your application.
 * var ngModule = angular.module('YourApp', ['ngAnimate']);
 * ngModule.animation('.my-crazy-animation', function() {
 *   return {
 *     enter: function(element, done) {
 *       //run the animation here and call done when the animation is complete
 *       return function(cancelled) {
 *         //this (optional) function will be called when the animation
 *         //completes or when the animation is cancelled (the cancelled
 *         //flag will be set to true if cancelled).
 *       };
 *     },
 *     leave: function(element, done) { },
 *     move: function(element, done) { },
 *
 *     //animation that can be triggered before the class is added
 *     beforeAddClass: function(element, className, done) { },
 *
 *     //animation that can be triggered after the class is added
 *     addClass: function(element, className, done) { },
 *
 *     //animation that can be triggered before the class is removed
 *     beforeRemoveClass: function(element, className, done) { },
 *
 *     //animation that can be triggered after the class is removed
 *     removeClass: function(element, className, done) { }
 *   };
 * });
 * ```
 *
 * JavaScript-defined animations are created with a CSS-like class selector and a collection of events which are set to run
 * a javascript callback function. When an animation is triggered, $animate will look for a matching animation which fits
 * the element's CSS class attribute value and then run the matching animation event function (if found).
 * In other words, if the CSS classes present on the animated element match any of the JavaScript animations then the callback function will
 * be executed. It should be also noted that only simple, single class selectors are allowed (compound class selectors are not supported).
 *
 * Within a JavaScript animation, an object containing various event callback animation functions is expected to be returned.
 * As explained above, these callbacks are triggered based on the animation event. Therefore if an enter animation is run,
 * and the JavaScript animation is found, then the enter callback will handle that animation (in addition to the CSS keyframe animation
 * or transition code that is defined via a stylesheet).
 *
 *
 * ### Applying Directive-specific Styles to an Animation
 * In some cases a directive or service may want to provide `$animate` with extra details that the animation will
 * include into its animation. Let's say for example we wanted to render an animation that animates an element
 * towards the mouse coordinates as to where the user clicked last. By collecting the X/Y coordinates of the click
 * (via the event parameter) we can set the `top` and `left` styles into an object and pass that into our function
 * call to `$animate.addClass`.
 *
 * ```js
 * canvas.on('click', function(e) {
 *   $animate.addClass(element, 'on', {
 *     to: {
 *       left : e.client.x + 'px',
 *       top : e.client.y + 'px'
 *     }
 *   }):
 * });
 * ```
 *
 * Now when the animation runs, and a transition or keyframe animation is picked up, then the animation itself will
 * also include and transition the styling of the `left` and `top` properties into its running animation. If we want
 * to provide some starting animation values then we can do so by placing the starting animations styles into an object
 * called `from` in the same object as the `to` animations.
 *
 * ```js
 * canvas.on('click', function(e) {
 *   $animate.addClass(element, 'on', {
 *     from: {
 *        position: 'absolute',
 *        left: '0px',
 *        top: '0px'
 *     },
 *     to: {
 *       left : e.client.x + 'px',
 *       top : e.client.y + 'px'
 *     }
 *   }):
 * });
 * ```
 *
 * Once the animation is complete or cancelled then the union of both the before and after styles are applied to the
 * element. If `ngAnimate` is not present then the styles will be applied immediately.
 *
 */
angular.module("ngAnimate",["ng"]).directive("ngAnimateChildren",function(){var NG_ANIMATE_CHILDREN="$$ngAnimateChildren";return function(scope,element,attrs){var val=attrs.ngAnimateChildren;angular.isString(val)&&0===val.length?//empty attribute
element.data(NG_ANIMATE_CHILDREN,!0):scope.$watch(val,function(value){element.data(NG_ANIMATE_CHILDREN,!!value)})}}).factory("$$animateReflow",["$$rAF","$document",function($$rAF,$document){var bod=$document[0].body;return function(fn){
//the returned function acts as the cancellation function
return $$rAF(function(){
//the line below will force the browser to perform a repaint
//so that all the animated elements within the animation frame
//will be properly updated and drawn on screen. This is
//required to perform multi-class CSS based animations with
//Firefox. DO NOT REMOVE THIS LINE.
bod.offsetWidth+1;fn()})}}]).config(["$provide","$animateProvider",function($provide,$animateProvider){function extractElementNode(element){for(var i=0;i<element.length;i++){var elm=element[i];if(elm.nodeType==ELEMENT_NODE)return elm}}function prepareElement(element){return element&&angular.element(element)}function stripCommentsFromElement(element){return angular.element(extractElementNode(element))}function isMatchingElement(elm1,elm2){return extractElementNode(elm1)==extractElementNode(elm2)}var noop=angular.noop,forEach=angular.forEach,selectors=$animateProvider.$$selectors,isArray=angular.isArray,isString=angular.isString,isObject=angular.isObject,ELEMENT_NODE=1,NG_ANIMATE_STATE="$$ngAnimateState",NG_ANIMATE_CHILDREN="$$ngAnimateChildren",NG_ANIMATE_CLASS_NAME="ng-animate",rootAnimateState={running:!0};$provide.decorator("$animate",["$delegate","$$q","$injector","$sniffer","$rootElement","$$asyncCallback","$rootScope","$document","$templateRequest",function($delegate,$$q,$injector,$sniffer,$rootElement,$$asyncCallback,$rootScope,$document,$templateRequest){function classBasedAnimationsBlocked(element,setter){var data=element.data(NG_ANIMATE_STATE)||{};return setter&&(data.running=!0,data.structural=!0,element.data(NG_ANIMATE_STATE,data)),data.disabled||data.running&&data.structural}function runAnimationPostDigest(fn){var cancelFn,defer=$$q.defer();return defer.promise.$$cancelFn=function(){cancelFn&&cancelFn()},$rootScope.$$postDigest(function(){cancelFn=fn(function(){defer.resolve()})}),defer.promise}function parseAnimateOptions(options){
// some plugin code may still be passing in the callback
// function as the last param for the $animate methods so
// it's best to only allow string or array values for now
// some plugin code may still be passing in the callback
// function as the last param for the $animate methods so
// it's best to only allow string or array values for now
return isObject(options)?(options.tempClasses&&isString(options.tempClasses)&&(options.tempClasses=options.tempClasses.split(/\s+/)),options):void 0}function resolveElementClasses(element,cache,runningAnimations){runningAnimations=runningAnimations||{};var lookup={};forEach(runningAnimations,function(data,selector){forEach(selector.split(" "),function(s){lookup[s]=data})});var hasClasses=Object.create(null);forEach((element.attr("class")||"").split(/\s+/),function(className){hasClasses[className]=!0});var toAdd=[],toRemove=[];return forEach(cache&&cache.classes||[],function(status,className){var hasClass=hasClasses[className],matchingAnimation=lookup[className]||{};
// When addClass and removeClass is called then $animate will check to
// see if addClass and removeClass cancel each other out. When there are
// more calls to removeClass than addClass then the count falls below 0
// and then the removeClass animation will be allowed. Otherwise if the
// count is above 0 then that means an addClass animation will commence.
// Once an animation is allowed then the code will also check to see if
// there exists any on-going animation that is already adding or remvoing
// the matching CSS class.
status===!1?
//does it have the class or will it have the class
(hasClass||"addClass"==matchingAnimation.event)&&toRemove.push(className):status===!0&&(
//is the class missing or will it be removed?
hasClass&&"removeClass"!=matchingAnimation.event||toAdd.push(className))}),toAdd.length+toRemove.length>0&&[toAdd.join(" "),toRemove.join(" ")]}function lookup(name){if(name){var matches=[],flagMap={},classes=name.substr(1).split(".");
//the empty string value is the default animation
//operation which performs CSS transition and keyframe
//animations sniffing. This is always included for each
//element animation procedure if the browser supports
//transitions and/or keyframe animations. The default
//animation is added to the top of the list to prevent
//any previous animations from affecting the element styling
//prior to the element being animated.
($sniffer.transitions||$sniffer.animations)&&matches.push($injector.get(selectors[""]));for(var i=0;i<classes.length;i++){var klass=classes[i],selectorFactoryName=selectors[klass];selectorFactoryName&&!flagMap[klass]&&(matches.push($injector.get(selectorFactoryName)),flagMap[klass]=!0)}return matches}}function animationRunner(element,animationEvent,className,options){function registerAnimation(animationFactory,event){var afterFn=animationFactory[event],beforeFn=animationFactory["before"+event.charAt(0).toUpperCase()+event.substr(1)];
//when set as null then animation knows to skip this phase
return afterFn||beforeFn?("leave"==event&&(beforeFn=afterFn,afterFn=null),after.push({event:event,fn:afterFn}),before.push({event:event,fn:beforeFn}),!0):void 0}function run(fns,cancellations,allCompleteFn){function afterAnimationComplete(index){if(cancellations){if((cancellations[index]||noop)(),++count<animations.length)return;cancellations=null}allCompleteFn()}var animations=[];forEach(fns,function(animation){animation.fn&&animations.push(animation)});var count=0;
//The code below adds directly to the array in order to work with
//both sync and async animations. Sync animations are when the done()
//operation is called right away. DO NOT REFACTOR!
forEach(animations,function(animation,index){var progress=function(){afterAnimationComplete(index)};switch(animation.event){case"setClass":cancellations.push(animation.fn(element,classNameAdd,classNameRemove,progress,options));break;case"animate":cancellations.push(animation.fn(element,className,options.from,options.to,progress));break;case"addClass":cancellations.push(animation.fn(element,classNameAdd||className,progress,options));break;case"removeClass":cancellations.push(animation.fn(element,classNameRemove||className,progress,options));break;default:cancellations.push(animation.fn(element,progress,options))}}),cancellations&&0===cancellations.length&&allCompleteFn()}
//transcluded directives may sometimes fire an animation using only comment nodes
//best to catch this early on to prevent any animation operations from occurring
var node=element[0];if(node){options&&(options.to=options.to||{},options.from=options.from||{});var classNameAdd,classNameRemove;isArray(className)&&(classNameAdd=className[0],classNameRemove=className[1],classNameAdd?classNameRemove?className=classNameAdd+" "+classNameRemove:(className=classNameAdd,animationEvent="addClass"):(className=classNameRemove,animationEvent="removeClass"));var isSetClassOperation="setClass"==animationEvent,isClassBased=isSetClassOperation||"addClass"==animationEvent||"removeClass"==animationEvent||"animate"==animationEvent,currentClassName=element.attr("class"),classes=currentClassName+" "+className;if(isAnimatableClassName(classes)){var beforeComplete=noop,beforeCancel=[],before=[],afterComplete=noop,afterCancel=[],after=[],animationLookup=(" "+classes).replace(/\s+/g,".");return forEach(lookup(animationLookup),function(animationFactory){var created=registerAnimation(animationFactory,animationEvent);!created&&isSetClassOperation&&(registerAnimation(animationFactory,"addClass"),registerAnimation(animationFactory,"removeClass"))}),{node:node,event:animationEvent,className:className,isClassBased:isClassBased,isSetClassOperation:isSetClassOperation,applyStyles:function(){options&&element.css(angular.extend(options.from||{},options.to||{}))},before:function(allCompleteFn){beforeComplete=allCompleteFn,run(before,beforeCancel,function(){beforeComplete=noop,allCompleteFn()})},after:function(allCompleteFn){afterComplete=allCompleteFn,run(after,afterCancel,function(){afterComplete=noop,allCompleteFn()})},cancel:function(){beforeCancel&&(forEach(beforeCancel,function(cancelFn){(cancelFn||noop)(!0)}),beforeComplete(!0)),afterCancel&&(forEach(afterCancel,function(cancelFn){(cancelFn||noop)(!0)}),afterComplete(!0))}}}}}/*
        all animations call this shared animation triggering function internally.
        The animationEvent variable refers to the JavaScript animation event that will be triggered
        and the className value is the name of the animation that will be applied within the
        CSS code. Element, parentElement and afterElement are provided DOM elements for the animation
        and the onComplete callback will be fired once the animation is fully complete.
      */
function performAnimation(animationEvent,className,element,parentElement,afterElement,domOperation,options,doneCallback){function fireDOMCallback(animationPhase){var eventName="$animate:"+animationPhase;elementEvents&&elementEvents[eventName]&&elementEvents[eventName].length>0&&$$asyncCallback(function(){element.triggerHandler(eventName,{event:animationEvent,className:className})})}function fireBeforeCallbackAsync(){fireDOMCallback("before")}function fireAfterCallbackAsync(){fireDOMCallback("after")}function fireDoneCallbackAsync(){fireDOMCallback("close"),doneCallback()}
//it is less complicated to use a flag than managing and canceling
//timeouts containing multiple callbacks.
function fireDOMOperation(){fireDOMOperation.hasBeenRun||(fireDOMOperation.hasBeenRun=!0,domOperation())}function closeAnimation(){if(!closeAnimation.hasBeenRun){runner&&//the runner doesn't exist if it fails to instantiate
runner.applyStyles(),closeAnimation.hasBeenRun=!0,options&&options.tempClasses&&forEach(options.tempClasses,function(className){element.removeClass(className)});var data=element.data(NG_ANIMATE_STATE);data&&(/* only structural animations wait for reflow before removing an
                 animation, but class-based animations don't. An example of this
                 failing would be when a parent HTML tag has a ng-class attribute
                 causing ALL directives below to skip animations during the digest */
runner&&runner.isClassBased?cleanup(element,className):($$asyncCallback(function(){var data=element.data(NG_ANIMATE_STATE)||{};localAnimationCount==data.index&&cleanup(element,className,animationEvent)}),element.data(NG_ANIMATE_STATE,data))),fireDoneCallbackAsync()}}var noopCancel=noop,runner=animationRunner(element,animationEvent,className,options);if(!runner)return fireDOMOperation(),fireBeforeCallbackAsync(),fireAfterCallbackAsync(),closeAnimation(),noopCancel;animationEvent=runner.event,className=runner.className;var elementEvents=angular.element._data(runner.node);
//skip the animation if animations are disabled, a parent is already being animated,
//the element is not currently attached to the document body or then completely close
//the animation if any matching animations are not found at all.
//NOTE: IE8 + IE9 should close properly (run closeAnimation()) in case an animation was found.
if(elementEvents=elementEvents&&elementEvents.events,parentElement||(parentElement=afterElement?afterElement.parent():element.parent()),animationsDisabled(element,parentElement))return fireDOMOperation(),fireBeforeCallbackAsync(),fireAfterCallbackAsync(),closeAnimation(),noopCancel;var ngAnimateState=element.data(NG_ANIMATE_STATE)||{},runningAnimations=ngAnimateState.active||{},totalActiveAnimations=ngAnimateState.totalActive||0,lastAnimation=ngAnimateState.last,skipAnimation=!1;if(totalActiveAnimations>0){var animationsToCancel=[];if(runner.isClassBased){if("setClass"==lastAnimation.event)animationsToCancel.push(lastAnimation),cleanup(element,className);else if(runningAnimations[className]){var current=runningAnimations[className];current.event==animationEvent?skipAnimation=!0:(animationsToCancel.push(current),cleanup(element,className))}}else if("leave"==animationEvent&&runningAnimations["ng-leave"])skipAnimation=!0;else{
//cancel all animations when a structural animation takes place
for(var klass in runningAnimations)animationsToCancel.push(runningAnimations[klass]);ngAnimateState={},cleanup(element,!0)}animationsToCancel.length>0&&forEach(animationsToCancel,function(operation){operation.cancel()})}if(!runner.isClassBased||runner.isSetClassOperation||"animate"==animationEvent||skipAnimation||(skipAnimation="addClass"==animationEvent==element.hasClass(className)),skipAnimation)return fireDOMOperation(),fireBeforeCallbackAsync(),fireAfterCallbackAsync(),fireDoneCallbackAsync(),noopCancel;runningAnimations=ngAnimateState.active||{},totalActiveAnimations=ngAnimateState.totalActive||0,"leave"==animationEvent&&element.one("$destroy",function(e){var element=angular.element(this),state=element.data(NG_ANIMATE_STATE);if(state){var activeLeaveAnimation=state.active["ng-leave"];activeLeaveAnimation&&(activeLeaveAnimation.cancel(),cleanup(element,"ng-leave"))}}),element.addClass(NG_ANIMATE_CLASS_NAME),options&&options.tempClasses&&forEach(options.tempClasses,function(className){element.addClass(className)});var localAnimationCount=globalAnimationCounter++;
//first we run the before animations and when all of those are complete
//then we perform the DOM operation and run the next set of animations
return totalActiveAnimations++,runningAnimations[className]=runner,element.data(NG_ANIMATE_STATE,{last:runner,active:runningAnimations,index:localAnimationCount,totalActive:totalActiveAnimations}),fireBeforeCallbackAsync(),runner.before(function(cancelled){var data=element.data(NG_ANIMATE_STATE);cancelled=cancelled||!data||!data.active[className]||runner.isClassBased&&data.active[className].event!=animationEvent,fireDOMOperation(),cancelled===!0?closeAnimation():(fireAfterCallbackAsync(),runner.after(closeAnimation))}),runner.cancel}function cancelChildAnimations(element){var node=extractElementNode(element);if(node){var nodes=angular.isFunction(node.getElementsByClassName)?node.getElementsByClassName(NG_ANIMATE_CLASS_NAME):node.querySelectorAll("."+NG_ANIMATE_CLASS_NAME);forEach(nodes,function(element){element=angular.element(element);var data=element.data(NG_ANIMATE_STATE);data&&data.active&&forEach(data.active,function(runner){runner.cancel()})})}}function cleanup(element,className){if(isMatchingElement(element,$rootElement))rootAnimateState.disabled||(rootAnimateState.running=!1,rootAnimateState.structural=!1);else if(className){var data=element.data(NG_ANIMATE_STATE)||{},removeAnimations=className===!0;!removeAnimations&&data.active&&data.active[className]&&(data.totalActive--,delete data.active[className]),(removeAnimations||!data.totalActive)&&(element.removeClass(NG_ANIMATE_CLASS_NAME),element.removeData(NG_ANIMATE_STATE))}}function animationsDisabled(element,parentElement){if(rootAnimateState.disabled)return!0;if(isMatchingElement(element,$rootElement))return rootAnimateState.running;var allowChildAnimations,parentRunningAnimation,hasParent;do{
//the element did not reach the root element which means that it
//is not apart of the DOM. Therefore there is no reason to do
//any animations on it
if(0===parentElement.length)break;var isRoot=isMatchingElement(parentElement,$rootElement),state=isRoot?rootAnimateState:parentElement.data(NG_ANIMATE_STATE)||{};if(state.disabled)return!0;
//once a flag is found that is strictly false then everything before
//it will be discarded and all child animations will be restricted
if(
//no matter what, for an animation to work it must reach the root element
//this implies that the element is attached to the DOM when the animation is run
isRoot&&(hasParent=!0),allowChildAnimations!==!1){var animateChildrenFlag=parentElement.data(NG_ANIMATE_CHILDREN);angular.isDefined(animateChildrenFlag)&&(allowChildAnimations=animateChildrenFlag)}parentRunningAnimation=parentRunningAnimation||state.running||state.last&&!state.last.isClassBased}while(parentElement=parentElement.parent());return!hasParent||!allowChildAnimations&&parentRunningAnimation}$rootElement.data(NG_ANIMATE_STATE,rootAnimateState);
// Wait until all directive and route-related templates are downloaded and
// compiled. The $templateRequest.totalPendingRequests variable keeps track of
// all of the remote templates being currently downloaded. If there are no
// templates currently downloading then the watcher will still fire anyway.
var deregisterWatch=$rootScope.$watch(function(){return $templateRequest.totalPendingRequests},function(val,oldVal){0===val&&(deregisterWatch(),
// Now that all templates have been downloaded, $animate will wait until
// the post digest queue is empty before enabling animations. By having two
// calls to $postDigest calls we can ensure that the flag is enabled at the
// very end of the post digest queue. Since all of the animations in $animate
// use $postDigest, it's important that the code below executes at the end.
// This basically means that the page is fully downloaded and compiled before
// any animations are triggered.
$rootScope.$$postDigest(function(){$rootScope.$$postDigest(function(){rootAnimateState.running=!1})}))}),globalAnimationCounter=0,classNameFilter=$animateProvider.classNameFilter(),isAnimatableClassName=classNameFilter?function(className){return classNameFilter.test(className)}:function(){return!0};/**
       * @ngdoc service
       * @name $animate
       * @kind object
       *
       * @description
       * The `$animate` service provides animation detection support while performing DOM operations (enter, leave and move) as well as during addClass and removeClass operations.
       * When any of these operations are run, the $animate service
       * will examine any JavaScript-defined animations (which are defined by using the $animateProvider provider object)
       * as well as any CSS-defined animations against the CSS classes present on the element once the DOM operation is run.
       *
       * The `$animate` service is used behind the scenes with pre-existing directives and animation with these directives
       * will work out of the box without any extra configuration.
       *
       * Requires the {@link ngAnimate `ngAnimate`} module to be installed.
       *
       * Please visit the {@link ngAnimate `ngAnimate`} module overview page learn more about how to use animations in your application.
       * ## Callback Promises
       * With AngularJS 1.3, each of the animation methods, on the `$animate` service, return a promise when called. The
       * promise itself is then resolved once the animation has completed itself, has been cancelled or has been
       * skipped due to animations being disabled. (Note that even if the animation is cancelled it will still
       * call the resolve function of the animation.)
       *
       * ```js
       * $animate.enter(element, container).then(function() {
       *   //...this is called once the animation is complete...
       * });
       * ```
       *
       * Also note that, due to the nature of the callback promise, if any Angular-specific code (like changing the scope,
       * location of the page, etc...) is executed within the callback promise then be sure to wrap the code using
       * `$scope.$apply(...)`;
       *
       * ```js
       * $animate.leave(element).then(function() {
       *   $scope.$apply(function() {
       *     $location.path('/new-page');
       *   });
       * });
       * ```
       *
       * An animation can also be cancelled by calling the `$animate.cancel(promise)` method with the provided
       * promise that was returned when the animation was started.
       *
       * ```js
       * var promise = $animate.addClass(element, 'super-long-animation').then(function() {
       *   //this will still be called even if cancelled
       * });
       *
       * element.on('click', function() {
       *   //tooo lazy to wait for the animation to end
       *   $animate.cancel(promise);
       * });
       * ```
       *
       * (Keep in mind that the promise cancellation is unique to `$animate` since promises in
       * general cannot be cancelled.)
       *
       */
return{/**
         * @ngdoc method
         * @name $animate#animate
         * @kind function
         *
         * @description
         * Performs an inline animation on the element which applies the provided `to` and `from` CSS styles to the element.
         * If any detected CSS transition, keyframe or JavaScript matches the provided `className` value then the animation
         * will take on the provided styles. For example, if a transition animation is set for the given className then the
         * provided `from` and `to` styles will be applied alongside the given transition. If a JavaScript animation is
         * detected then the provided styles will be given in as function paramters.
         *
         * ```js
         * ngModule.animation('.my-inline-animation', function() {
         *   return {
         *     animate : function(element, className, from, to, done) {
         *       //styles
         *     }
         *   }
         * });
         * ```
         *
         * Below is a breakdown of each step that occurs during the `animate` animation:
         *
         * | Animation Step                                                                                                    | What the element class attribute looks like                |
         * |-------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------|
         * | 1. $animate.animate(...) is called                                                                                | class="my-animation"                                       |
         * | 2. $animate waits for the next digest to start the animation                                                      | class="my-animation ng-animate"                            |
         * | 3. $animate runs the JavaScript-defined animations detected on the element                                        | class="my-animation ng-animate"                            |
         * | 4. the className class value is added to the element                                                              | class="my-animation ng-animate className"                  |
         * | 5. $animate scans the element styles to get the CSS transition/animation duration and delay                       | class="my-animation ng-animate className"                  |
         * | 6. $animate blocks all CSS transitions on the element to ensure the .className class styling is applied right away| class="my-animation ng-animate className"                  |
         * | 7. $animate applies the provided collection of `from` CSS styles to the element                                   | class="my-animation ng-animate className"                  |
         * | 8. $animate waits for a single animation frame (this performs a reflow)                                           | class="my-animation ng-animate className"                  |
         * | 9. $animate removes the CSS transition block placed on the element                                                | class="my-animation ng-animate className"                  |
         * | 10. the className-active class is added (this triggers the CSS transition/animation)                              | class="my-animation ng-animate className className-active" |
         * | 11. $animate applies the collection of `to` CSS styles to the element which are then handled by the transition    | class="my-animation ng-animate className className-active" |
         * | 12. $animate waits for the animation to complete (via events and timeout)                                         | class="my-animation ng-animate className className-active" |
         * | 13. The animation ends and all generated CSS classes are removed from the element                                 | class="my-animation"                                       |
         * | 14. The returned promise is resolved.                                                                             | class="my-animation"                                       |
         *
         * @param {DOMElement} element the element that will be the focus of the enter animation
         * @param {object} from a collection of CSS styles that will be applied to the element at the start of the animation
         * @param {object} to a collection of CSS styles that the element will animate towards
         * @param {string=} className an optional CSS class that will be added to the element for the duration of the animation (the default class is `ng-inline-animate`)
         * @param {object=} options an optional collection of options that will be picked up by the CSS transition/animation
         * @return {Promise} the animation callback promise
        */
animate:function(element,from,to,className,options){return className=className||"ng-inline-animate",options=parseAnimateOptions(options)||{},options.from=to?from:null,options.to=to?to:from,runAnimationPostDigest(function(done){return performAnimation("animate",className,stripCommentsFromElement(element),null,null,noop,options,done)})},/**
         * @ngdoc method
         * @name $animate#enter
         * @kind function
         *
         * @description
         * Appends the element to the parentElement element that resides in the document and then runs the enter animation. Once
         * the animation is started, the following CSS classes will be present on the element for the duration of the animation:
         *
         * Below is a breakdown of each step that occurs during enter animation:
         *
         * | Animation Step                                                                                                    | What the element class attribute looks like              |
         * |-------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------|
         * | 1. $animate.enter(...) is called                                                                                  | class="my-animation"                                     |
         * | 2. element is inserted into the parentElement element or beside the afterElement element                          | class="my-animation"                                     |
         * | 3. $animate waits for the next digest to start the animation                                                      | class="my-animation ng-animate"                          |
         * | 4. $animate runs the JavaScript-defined animations detected on the element                                        | class="my-animation ng-animate"                          |
         * | 5. the .ng-enter class is added to the element                                                                    | class="my-animation ng-animate ng-enter"                 |
         * | 6. $animate scans the element styles to get the CSS transition/animation duration and delay                       | class="my-animation ng-animate ng-enter"                 |
         * | 7. $animate blocks all CSS transitions on the element to ensure the .ng-enter class styling is applied right away | class="my-animation ng-animate ng-enter"                 |
         * | 8. $animate waits for a single animation frame (this performs a reflow)                                           | class="my-animation ng-animate ng-enter"                 |
         * | 9. $animate removes the CSS transition block placed on the element                                                | class="my-animation ng-animate ng-enter"                 |
         * | 10. the .ng-enter-active class is added (this triggers the CSS transition/animation)                              | class="my-animation ng-animate ng-enter ng-enter-active" |
         * | 11. $animate waits for the animation to complete (via events and timeout)                                         | class="my-animation ng-animate ng-enter ng-enter-active" |
         * | 12. The animation ends and all generated CSS classes are removed from the element                                 | class="my-animation"                                     |
         * | 13. The returned promise is resolved.                                                                             | class="my-animation"                                     |
         *
         * @param {DOMElement} element the element that will be the focus of the enter animation
         * @param {DOMElement} parentElement the parent element of the element that will be the focus of the enter animation
         * @param {DOMElement} afterElement the sibling element (which is the previous element) of the element that will be the focus of the enter animation
         * @param {object=} options an optional collection of options that will be picked up by the CSS transition/animation
         * @return {Promise} the animation callback promise
        */
enter:function(element,parentElement,afterElement,options){return options=parseAnimateOptions(options),element=angular.element(element),parentElement=prepareElement(parentElement),afterElement=prepareElement(afterElement),classBasedAnimationsBlocked(element,!0),$delegate.enter(element,parentElement,afterElement),runAnimationPostDigest(function(done){return performAnimation("enter","ng-enter",stripCommentsFromElement(element),parentElement,afterElement,noop,options,done)})},/**
         * @ngdoc method
         * @name $animate#leave
         * @kind function
         *
         * @description
         * Runs the leave animation operation and, upon completion, removes the element from the DOM. Once
         * the animation is started, the following CSS classes will be added for the duration of the animation:
         *
         * Below is a breakdown of each step that occurs during leave animation:
         *
         * | Animation Step                                                                                                    | What the element class attribute looks like              |
         * |-------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------|
         * | 1. $animate.leave(...) is called                                                                                  | class="my-animation"                                     |
         * | 2. $animate runs the JavaScript-defined animations detected on the element                                        | class="my-animation ng-animate"                          |
         * | 3. $animate waits for the next digest to start the animation                                                      | class="my-animation ng-animate"                          |
         * | 4. the .ng-leave class is added to the element                                                                    | class="my-animation ng-animate ng-leave"                 |
         * | 5. $animate scans the element styles to get the CSS transition/animation duration and delay                       | class="my-animation ng-animate ng-leave"                 |
         * | 6. $animate blocks all CSS transitions on the element to ensure the .ng-leave class styling is applied right away | class="my-animation ng-animate ng-leave"                 |
         * | 7. $animate waits for a single animation frame (this performs a reflow)                                           | class="my-animation ng-animate ng-leave"                 |
         * | 8. $animate removes the CSS transition block placed on the element                                                | class="my-animation ng-animate ng-leave"                 |
         * | 9. the .ng-leave-active class is added (this triggers the CSS transition/animation)                               | class="my-animation ng-animate ng-leave ng-leave-active" |
         * | 10. $animate waits for the animation to complete (via events and timeout)                                         | class="my-animation ng-animate ng-leave ng-leave-active" |
         * | 11. The animation ends and all generated CSS classes are removed from the element                                 | class="my-animation"                                     |
         * | 12. The element is removed from the DOM                                                                           | ...                                                      |
         * | 13. The returned promise is resolved.                                                                             | ...                                                      |
         *
         * @param {DOMElement} element the element that will be the focus of the leave animation
         * @param {object=} options an optional collection of styles that will be picked up by the CSS transition/animation
         * @return {Promise} the animation callback promise
        */
leave:function(element,options){return options=parseAnimateOptions(options),element=angular.element(element),cancelChildAnimations(element),classBasedAnimationsBlocked(element,!0),runAnimationPostDigest(function(done){return performAnimation("leave","ng-leave",stripCommentsFromElement(element),null,null,function(){$delegate.leave(element)},options,done)})},/**
         * @ngdoc method
         * @name $animate#move
         * @kind function
         *
         * @description
         * Fires the move DOM operation. Just before the animation starts, the animate service will either append it into the parentElement container or
         * add the element directly after the afterElement element if present. Then the move animation will be run. Once
         * the animation is started, the following CSS classes will be added for the duration of the animation:
         *
         * Below is a breakdown of each step that occurs during move animation:
         *
         * | Animation Step                                                                                                   | What the element class attribute looks like            |
         * |------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------|
         * | 1. $animate.move(...) is called                                                                                  | class="my-animation"                                   |
         * | 2. element is moved into the parentElement element or beside the afterElement element                            | class="my-animation"                                   |
         * | 3. $animate waits for the next digest to start the animation                                                     | class="my-animation ng-animate"                        |
         * | 4. $animate runs the JavaScript-defined animations detected on the element                                       | class="my-animation ng-animate"                        |
         * | 5. the .ng-move class is added to the element                                                                    | class="my-animation ng-animate ng-move"                |
         * | 6. $animate scans the element styles to get the CSS transition/animation duration and delay                      | class="my-animation ng-animate ng-move"                |
         * | 7. $animate blocks all CSS transitions on the element to ensure the .ng-move class styling is applied right away | class="my-animation ng-animate ng-move"                |
         * | 8. $animate waits for a single animation frame (this performs a reflow)                                          | class="my-animation ng-animate ng-move"                |
         * | 9. $animate removes the CSS transition block placed on the element                                               | class="my-animation ng-animate ng-move"                |
         * | 10. the .ng-move-active class is added (this triggers the CSS transition/animation)                              | class="my-animation ng-animate ng-move ng-move-active" |
         * | 11. $animate waits for the animation to complete (via events and timeout)                                        | class="my-animation ng-animate ng-move ng-move-active" |
         * | 12. The animation ends and all generated CSS classes are removed from the element                                | class="my-animation"                                   |
         * | 13. The returned promise is resolved.                                                                            | class="my-animation"                                   |
         *
         * @param {DOMElement} element the element that will be the focus of the move animation
         * @param {DOMElement} parentElement the parentElement element of the element that will be the focus of the move animation
         * @param {DOMElement} afterElement the sibling element (which is the previous element) of the element that will be the focus of the move animation
         * @param {object=} options an optional collection of styles that will be picked up by the CSS transition/animation
         * @return {Promise} the animation callback promise
        */
move:function(element,parentElement,afterElement,options){return options=parseAnimateOptions(options),element=angular.element(element),parentElement=prepareElement(parentElement),afterElement=prepareElement(afterElement),cancelChildAnimations(element),classBasedAnimationsBlocked(element,!0),$delegate.move(element,parentElement,afterElement),runAnimationPostDigest(function(done){return performAnimation("move","ng-move",stripCommentsFromElement(element),parentElement,afterElement,noop,options,done)})},/**
         * @ngdoc method
         * @name $animate#addClass
         *
         * @description
         * Triggers a custom animation event based off the className variable and then attaches the className value to the element as a CSS class.
         * Unlike the other animation methods, the animate service will suffix the className value with {@type -add} in order to provide
         * the animate service the setup and active CSS classes in order to trigger the animation (this will be skipped if no CSS transitions
         * or keyframes are defined on the -add-active or base CSS class).
         *
         * Below is a breakdown of each step that occurs during addClass animation:
         *
         * | Animation Step                                                                                     | What the element class attribute looks like                      |
         * |----------------------------------------------------------------------------------------------------|------------------------------------------------------------------|
         * | 1. $animate.addClass(element, 'super') is called                                                   | class="my-animation"                                             |
         * | 2. $animate runs the JavaScript-defined animations detected on the element                         | class="my-animation ng-animate"                                  |
         * | 3. the .super-add class is added to the element                                                    | class="my-animation ng-animate super-add"                        |
         * | 4. $animate waits for a single animation frame (this performs a reflow)                            | class="my-animation ng-animate super-add"                        |
         * | 5. the .super and .super-add-active classes are added (this triggers the CSS transition/animation) | class="my-animation ng-animate super super-add super-add-active" |
         * | 6. $animate scans the element styles to get the CSS transition/animation duration and delay        | class="my-animation ng-animate super super-add super-add-active" |
         * | 7. $animate waits for the animation to complete (via events and timeout)                           | class="my-animation ng-animate super super-add super-add-active" |
         * | 8. The animation ends and all generated CSS classes are removed from the element                   | class="my-animation super"                                       |
         * | 9. The super class is kept on the element                                                          | class="my-animation super"                                       |
         * | 10. The returned promise is resolved.                                                              | class="my-animation super"                                       |
         *
         * @param {DOMElement} element the element that will be animated
         * @param {string} className the CSS class that will be added to the element and then animated
         * @param {object=} options an optional collection of styles that will be picked up by the CSS transition/animation
         * @return {Promise} the animation callback promise
        */
addClass:function(element,className,options){return this.setClass(element,className,[],options)},/**
         * @ngdoc method
         * @name $animate#removeClass
         *
         * @description
         * Triggers a custom animation event based off the className variable and then removes the CSS class provided by the className value
         * from the element. Unlike the other animation methods, the animate service will suffix the className value with {@type -remove} in
         * order to provide the animate service the setup and active CSS classes in order to trigger the animation (this will be skipped if
         * no CSS transitions or keyframes are defined on the -remove or base CSS classes).
         *
         * Below is a breakdown of each step that occurs during removeClass animation:
         *
         * | Animation Step                                                                                                   | What the element class attribute looks like                      |
         * |------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------|
         * | 1. $animate.removeClass(element, 'super') is called                                                              | class="my-animation super"                                       |
         * | 2. $animate runs the JavaScript-defined animations detected on the element                                       | class="my-animation super ng-animate"                            |
         * | 3. the .super-remove class is added to the element                                                               | class="my-animation super ng-animate super-remove"               |
         * | 4. $animate waits for a single animation frame (this performs a reflow)                                          | class="my-animation super ng-animate super-remove"               |
         * | 5. the .super-remove-active classes are added and .super is removed (this triggers the CSS transition/animation) | class="my-animation ng-animate super-remove super-remove-active" |
         * | 6. $animate scans the element styles to get the CSS transition/animation duration and delay                      | class="my-animation ng-animate super-remove super-remove-active" |
         * | 7. $animate waits for the animation to complete (via events and timeout)                                         | class="my-animation ng-animate super-remove super-remove-active" |
         * | 8. The animation ends and all generated CSS classes are removed from the element                                 | class="my-animation"                                             |
         * | 9. The returned promise is resolved.                                                                             | class="my-animation"                                             |
         *
         *
         * @param {DOMElement} element the element that will be animated
         * @param {string} className the CSS class that will be animated and then removed from the element
         * @param {object=} options an optional collection of styles that will be picked up by the CSS transition/animation
         * @return {Promise} the animation callback promise
        */
removeClass:function(element,className,options){return this.setClass(element,[],className,options)},/**
         *
         * @ngdoc method
         * @name $animate#setClass
         *
         * @description Adds and/or removes the given CSS classes to and from the element.
         * Once complete, the done() callback will be fired (if provided).
         *
         * | Animation Step                                                                                                                       | What the element class attribute looks like                                          |
         * |--------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------|
         * | 1. $animate.setClass(element, 'on', 'off') is called                                                                                 | class="my-animation off"                                                             |
         * | 2. $animate runs the JavaScript-defined animations detected on the element                                                           | class="my-animation ng-animate off"                                                  |
         * | 3. the .on-add and .off-remove classes are added to the element                                                                      | class="my-animation ng-animate on-add off-remove off"                                |
         * | 4. $animate waits for a single animation frame (this performs a reflow)                                                              | class="my-animation ng-animate on-add off-remove off"                                |
         * | 5. the .on, .on-add-active and .off-remove-active classes are added and .off is removed (this triggers the CSS transition/animation) | class="my-animation ng-animate on on-add on-add-active off-remove off-remove-active" |
         * | 6. $animate scans the element styles to get the CSS transition/animation duration and delay                                          | class="my-animation ng-animate on on-add on-add-active off-remove off-remove-active" |
         * | 7. $animate waits for the animation to complete (via events and timeout)                                                             | class="my-animation ng-animate on on-add on-add-active off-remove off-remove-active" |
         * | 8. The animation ends and all generated CSS classes are removed from the element                                                     | class="my-animation on"                                                              |
         * | 9. The returned promise is resolved.                                                                                                 | class="my-animation on"                                                              |
         *
         * @param {DOMElement} element the element which will have its CSS classes changed
         *   removed from it
         * @param {string} add the CSS classes which will be added to the element
         * @param {string} remove the CSS class which will be removed from the element
         *   CSS classes have been set on the element
         * @param {object=} options an optional collection of styles that will be picked up by the CSS transition/animation
         * @return {Promise} the animation callback promise
         */
setClass:function(element,add,remove,options){options=parseAnimateOptions(options);var STORAGE_KEY="$$animateClasses";if(element=angular.element(element),element=stripCommentsFromElement(element),classBasedAnimationsBlocked(element))return $delegate.$$setClassImmediately(element,add,remove,options);
// we're using a combined array for both the add and remove
// operations since the ORDER OF addClass and removeClass matters
var classes,cache=element.data(STORAGE_KEY),hasCache=!!cache;return cache||(cache={},cache.classes={}),classes=cache.classes,add=isArray(add)?add:add.split(" "),forEach(add,function(c){c&&c.length&&(classes[c]=!0)}),remove=isArray(remove)?remove:remove.split(" "),forEach(remove,function(c){c&&c.length&&(classes[c]=!1)}),hasCache?(options&&cache.options&&(cache.options=angular.extend(cache.options||{},options)),cache.promise):(element.data(STORAGE_KEY,cache={classes:classes,options:options}),cache.promise=runAnimationPostDigest(function(done){var parentElement=element.parent(),elementNode=extractElementNode(element),parentNode=elementNode.parentNode;
// TODO(matsko): move this code into the animationsDisabled() function once #8092 is fixed
if(!parentNode||parentNode.$$NG_REMOVED||elementNode.$$NG_REMOVED)return void done();var cache=element.data(STORAGE_KEY);element.removeData(STORAGE_KEY);var state=element.data(NG_ANIMATE_STATE)||{},classes=resolveElementClasses(element,cache,state.active);return classes?performAnimation("setClass",classes,element,parentElement,null,function(){classes[0]&&$delegate.$$addClassImmediately(element,classes[0]),classes[1]&&$delegate.$$removeClassImmediately(element,classes[1])},cache.options,done):done()}))},/**
         * @ngdoc method
         * @name $animate#cancel
         * @kind function
         *
         * @param {Promise} animationPromise The animation promise that is returned when an animation is started.
         *
         * @description
         * Cancels the provided animation.
        */
cancel:function(promise){promise.$$cancelFn()},/**
         * @ngdoc method
         * @name $animate#enabled
         * @kind function
         *
         * @param {boolean=} value If provided then set the animation on or off.
         * @param {DOMElement=} element If provided then the element will be used to represent the enable/disable operation
         * @return {boolean} Current animation state.
         *
         * @description
         * Globally enables/disables animations.
         *
        */
enabled:function(value,element){switch(arguments.length){case 2:if(value)cleanup(element);else{var data=element.data(NG_ANIMATE_STATE)||{};data.disabled=!0,element.data(NG_ANIMATE_STATE,data)}break;case 1:rootAnimateState.disabled=!value;break;default:value=!rootAnimateState.disabled}return!!value}}}]),$animateProvider.register("",["$window","$sniffer","$timeout","$$animateReflow",function($window,$sniffer,$timeout,$$animateReflow){function clearCacheAfterReflow(){cancelAnimationReflow||(cancelAnimationReflow=$$animateReflow(function(){animationReflowQueue=[],cancelAnimationReflow=null,lookupCache={}}))}function afterReflow(element,callback){cancelAnimationReflow&&cancelAnimationReflow(),animationReflowQueue.push(callback),cancelAnimationReflow=$$animateReflow(function(){forEach(animationReflowQueue,function(fn){fn()}),animationReflowQueue=[],cancelAnimationReflow=null,lookupCache={}})}function animationCloseHandler(element,totalTime){var node=extractElementNode(element);element=angular.element(node),animationElementQueue.push(element);
//but it may not need to cancel out the existing timeout
//if the timestamp is less than the previous one
var futureTimestamp=Date.now()+totalTime;closingTimestamp>=futureTimestamp||($timeout.cancel(closingTimer),closingTimestamp=futureTimestamp,closingTimer=$timeout(function(){closeAllAnimations(animationElementQueue),animationElementQueue=[]},totalTime,!1))}function closeAllAnimations(elements){forEach(elements,function(element){var elementData=element.data(NG_ANIMATE_CSS_DATA_KEY);elementData&&forEach(elementData.closeAnimationFns,function(fn){fn()})})}function getElementAnimationDetails(element,cacheKey){var data=cacheKey?lookupCache[cacheKey]:null;if(!data){var transitionDuration=0,transitionDelay=0,animationDuration=0,animationDelay=0;
//we want all the styles defined before and after
forEach(element,function(element){if(element.nodeType==ELEMENT_NODE){var elementStyles=$window.getComputedStyle(element)||{},transitionDurationStyle=elementStyles[TRANSITION_PROP+DURATION_KEY];transitionDuration=Math.max(parseMaxTime(transitionDurationStyle),transitionDuration);var transitionDelayStyle=elementStyles[TRANSITION_PROP+DELAY_KEY];transitionDelay=Math.max(parseMaxTime(transitionDelayStyle),transitionDelay);elementStyles[ANIMATION_PROP+DELAY_KEY];animationDelay=Math.max(parseMaxTime(elementStyles[ANIMATION_PROP+DELAY_KEY]),animationDelay);var aDuration=parseMaxTime(elementStyles[ANIMATION_PROP+DURATION_KEY]);aDuration>0&&(aDuration*=parseInt(elementStyles[ANIMATION_PROP+ANIMATION_ITERATION_COUNT_KEY],10)||1),animationDuration=Math.max(aDuration,animationDuration)}}),data={total:0,transitionDelay:transitionDelay,transitionDuration:transitionDuration,animationDelay:animationDelay,animationDuration:animationDuration},cacheKey&&(lookupCache[cacheKey]=data)}return data}function parseMaxTime(str){var maxValue=0,values=isString(str)?str.split(/\s*,\s*/):[];return forEach(values,function(value){maxValue=Math.max(parseFloat(value)||0,maxValue)}),maxValue}function getCacheKey(element){var parentElement=element.parent(),parentID=parentElement.data(NG_ANIMATE_PARENT_KEY);return parentID||(parentElement.data(NG_ANIMATE_PARENT_KEY,++parentCounter),parentID=parentCounter),parentID+"-"+extractElementNode(element).getAttribute("class")}function animateSetup(animationEvent,element,className,styles){var structural=["ng-enter","ng-leave","ng-move"].indexOf(className)>=0,cacheKey=getCacheKey(element),eventCacheKey=cacheKey+" "+className,itemIndex=lookupCache[eventCacheKey]?++lookupCache[eventCacheKey].total:0,stagger={};if(itemIndex>0){var staggerClassName=className+"-stagger",staggerCacheKey=cacheKey+" "+staggerClassName,applyClasses=!lookupCache[staggerCacheKey];applyClasses&&element.addClass(staggerClassName),stagger=getElementAnimationDetails(element,staggerCacheKey),applyClasses&&element.removeClass(staggerClassName)}element.addClass(className);var formerData=element.data(NG_ANIMATE_CSS_DATA_KEY)||{},timings=getElementAnimationDetails(element,eventCacheKey),transitionDuration=timings.transitionDuration,animationDuration=timings.animationDuration;if(structural&&0===transitionDuration&&0===animationDuration)return element.removeClass(className),!1;var blockTransition=styles||structural&&transitionDuration>0,blockAnimation=animationDuration>0&&stagger.animationDelay>0&&0===stagger.animationDuration,closeAnimationFns=formerData.closeAnimationFns||[];element.data(NG_ANIMATE_CSS_DATA_KEY,{stagger:stagger,cacheKey:eventCacheKey,running:formerData.running||0,itemIndex:itemIndex,blockTransition:blockTransition,closeAnimationFns:closeAnimationFns});var node=extractElementNode(element);return blockTransition&&(blockTransitions(node,!0),styles&&element.css(styles)),blockAnimation&&blockAnimations(node,!0),!0}function animateRun(animationEvent,element,className,activeAnimationComplete,styles){
// This will automatically be called by $animate so
// there is no need to attach this internally to the
// timeout done method.
function onEnd(){element.off(css3AnimationEvents,onAnimationProgress),element.removeClass(activeClassName),element.removeClass(pendingClassName),staggerTimeout&&$timeout.cancel(staggerTimeout),animateClose(element,className);var node=extractElementNode(element);for(var i in appliedStyles)node.style.removeProperty(appliedStyles[i])}function onAnimationProgress(event){event.stopPropagation();var ev=event.originalEvent||event,timeStamp=ev.$manualTimeStamp||ev.timeStamp||Date.now(),elapsedTime=parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));/* $manualTimeStamp is a mocked timeStamp value which is set
           * within browserTrigger(). This is only here so that tests can
           * mock animations properly. Real events fallback to event.timeStamp,
           * or, if they don't, then a timeStamp is automatically created for them.
           * We're checking to see if the timeStamp surpasses the expected delay,
           * but we're using elapsedTime instead of the timeStamp on the 2nd
           * pre-condition since animations sometimes close off early */
Math.max(timeStamp-startTime,0)>=maxDelayTime&&elapsedTime>=maxDuration&&activeAnimationComplete()}var node=extractElementNode(element),elementData=element.data(NG_ANIMATE_CSS_DATA_KEY);if(-1==node.getAttribute("class").indexOf(className)||!elementData)return void activeAnimationComplete();var activeClassName="",pendingClassName="";forEach(className.split(" "),function(klass,i){var prefix=(i>0?" ":"")+klass;activeClassName+=prefix+"-active",pendingClassName+=prefix+"-pending"});var style="",appliedStyles=[],itemIndex=elementData.itemIndex,stagger=elementData.stagger,staggerTime=0;if(itemIndex>0){var transitionStaggerDelay=0;stagger.transitionDelay>0&&0===stagger.transitionDuration&&(transitionStaggerDelay=stagger.transitionDelay*itemIndex);var animationStaggerDelay=0;stagger.animationDelay>0&&0===stagger.animationDuration&&(animationStaggerDelay=stagger.animationDelay*itemIndex,appliedStyles.push(CSS_PREFIX+"animation-play-state")),staggerTime=Math.round(100*Math.max(transitionStaggerDelay,animationStaggerDelay))/100}staggerTime||(element.addClass(activeClassName),elementData.blockTransition&&blockTransitions(node,!1));var eventCacheKey=elementData.cacheKey+" "+activeClassName,timings=getElementAnimationDetails(element,eventCacheKey),maxDuration=Math.max(timings.transitionDuration,timings.animationDuration);if(0===maxDuration)return element.removeClass(activeClassName),animateClose(element,className),void activeAnimationComplete();!staggerTime&&styles&&(timings.transitionDuration||(element.css("transition",timings.animationDuration+"s linear all"),appliedStyles.push("transition")),element.css(styles));var maxDelay=Math.max(timings.transitionDelay,timings.animationDelay),maxDelayTime=maxDelay*ONE_SECOND;if(appliedStyles.length>0){
//the element being animated may sometimes contain comment nodes in
//the jqLite object, so we're safe to use a single variable to house
//the styles since there is always only one element being animated
var oldStyle=node.getAttribute("style")||"";";"!==oldStyle.charAt(oldStyle.length-1)&&(oldStyle+=";"),node.setAttribute("style",oldStyle+" "+style)}var staggerTimeout,startTime=Date.now(),css3AnimationEvents=ANIMATIONEND_EVENT+" "+TRANSITIONEND_EVENT,animationTime=(maxDelay+maxDuration)*CLOSING_TIME_BUFFER,totalTime=(staggerTime+animationTime)*ONE_SECOND;return staggerTime>0&&(element.addClass(pendingClassName),staggerTimeout=$timeout(function(){staggerTimeout=null,timings.transitionDuration>0&&blockTransitions(node,!1),timings.animationDuration>0&&blockAnimations(node,!1),element.addClass(activeClassName),element.removeClass(pendingClassName),styles&&(0===timings.transitionDuration&&element.css("transition",timings.animationDuration+"s linear all"),element.css(styles),appliedStyles.push("transition"))},staggerTime*ONE_SECOND,!1)),element.on(css3AnimationEvents,onAnimationProgress),elementData.closeAnimationFns.push(function(){onEnd(),activeAnimationComplete()}),elementData.running++,animationCloseHandler(element,totalTime),onEnd}function blockTransitions(node,bool){node.style[TRANSITION_PROP+PROPERTY_KEY]=bool?"none":""}function blockAnimations(node,bool){node.style[ANIMATION_PROP+ANIMATION_PLAYSTATE_KEY]=bool?"paused":""}function animateBefore(animationEvent,element,className,styles){return animateSetup(animationEvent,element,className,styles)?function(cancelled){cancelled&&animateClose(element,className)}:void 0}function animateAfter(animationEvent,element,className,afterAnimationComplete,styles){return element.data(NG_ANIMATE_CSS_DATA_KEY)?animateRun(animationEvent,element,className,afterAnimationComplete,styles):(animateClose(element,className),void afterAnimationComplete())}function animate(animationEvent,element,className,animationComplete,options){
//If the animateSetup function doesn't bother returning a
//cancellation function then it means that there is no animation
//to perform at all
var preReflowCancellation=animateBefore(animationEvent,element,className,options.from);if(!preReflowCancellation)return clearCacheAfterReflow(),void animationComplete();
//There are two cancellation functions: one is before the first
//reflow animation and the second is during the active state
//animation. The first function will take care of removing the
//data from the element which will not make the 2nd animation
//happen in the first place
var cancel=preReflowCancellation;return afterReflow(element,function(){
//once the reflow is complete then we point cancel to
//the new cancellation function which will remove all of the
//animation properties from the active animation
cancel=animateAfter(animationEvent,element,className,animationComplete,options.to)}),function(cancelled){(cancel||noop)(cancelled)}}function animateClose(element,className){element.removeClass(className);var data=element.data(NG_ANIMATE_CSS_DATA_KEY);data&&(data.running&&data.running--,data.running&&0!==data.running||element.removeData(NG_ANIMATE_CSS_DATA_KEY))}function suffixClasses(classes,suffix){var className="";return classes=isArray(classes)?classes:classes.split(/\s+/),forEach(classes,function(klass,i){klass&&klass.length>0&&(className+=(i>0?" ":"")+klass+suffix)}),className}
// Detect proper transitionend/animationend event names.
var TRANSITION_PROP,TRANSITIONEND_EVENT,ANIMATION_PROP,ANIMATIONEND_EVENT,CSS_PREFIX="";
// If unprefixed events are not supported but webkit-prefixed are, use the latter.
// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.
// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`
// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.
// Register both events in case `window.onanimationend` is not supported because of that,
// do the same for `transitionend` as Safari is likely to exhibit similar behavior.
// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit
// therefore there is no reason to test anymore for other vendor prefixes: http://caniuse.com/#search=transition
window.ontransitionend===undefined&&window.onwebkittransitionend!==undefined?(CSS_PREFIX="-webkit-",TRANSITION_PROP="WebkitTransition",TRANSITIONEND_EVENT="webkitTransitionEnd transitionend"):(TRANSITION_PROP="transition",TRANSITIONEND_EVENT="transitionend"),window.onanimationend===undefined&&window.onwebkitanimationend!==undefined?(CSS_PREFIX="-webkit-",ANIMATION_PROP="WebkitAnimation",ANIMATIONEND_EVENT="webkitAnimationEnd animationend"):(ANIMATION_PROP="animation",ANIMATIONEND_EVENT="animationend");var cancelAnimationReflow,DURATION_KEY="Duration",PROPERTY_KEY="Property",DELAY_KEY="Delay",ANIMATION_ITERATION_COUNT_KEY="IterationCount",ANIMATION_PLAYSTATE_KEY="PlayState",NG_ANIMATE_PARENT_KEY="$$ngAnimateKey",NG_ANIMATE_CSS_DATA_KEY="$$ngAnimateCSS3Data",ELAPSED_TIME_MAX_DECIMAL_PLACES=3,CLOSING_TIME_BUFFER=1.5,ONE_SECOND=1e3,lookupCache={},parentCounter=0,animationReflowQueue=[],closingTimer=null,closingTimestamp=0,animationElementQueue=[];return{animate:function(element,className,from,to,animationCompleted,options){return options=options||{},options.from=from,options.to=to,animate("animate",element,className,animationCompleted,options)},enter:function(element,animationCompleted,options){return options=options||{},animate("enter",element,"ng-enter",animationCompleted,options)},leave:function(element,animationCompleted,options){return options=options||{},animate("leave",element,"ng-leave",animationCompleted,options)},move:function(element,animationCompleted,options){return options=options||{},animate("move",element,"ng-move",animationCompleted,options)},beforeSetClass:function(element,add,remove,animationCompleted,options){options=options||{};var className=suffixClasses(remove,"-remove")+" "+suffixClasses(add,"-add"),cancellationMethod=animateBefore("setClass",element,className,options.from);return cancellationMethod?(afterReflow(element,animationCompleted),cancellationMethod):(clearCacheAfterReflow(),void animationCompleted())},beforeAddClass:function(element,className,animationCompleted,options){options=options||{};var cancellationMethod=animateBefore("addClass",element,suffixClasses(className,"-add"),options.from);return cancellationMethod?(afterReflow(element,animationCompleted),cancellationMethod):(clearCacheAfterReflow(),void animationCompleted())},beforeRemoveClass:function(element,className,animationCompleted,options){options=options||{};var cancellationMethod=animateBefore("removeClass",element,suffixClasses(className,"-remove"),options.from);return cancellationMethod?(afterReflow(element,animationCompleted),cancellationMethod):(clearCacheAfterReflow(),void animationCompleted())},setClass:function(element,add,remove,animationCompleted,options){options=options||{},remove=suffixClasses(remove,"-remove"),add=suffixClasses(add,"-add");var className=remove+" "+add;return animateAfter("setClass",element,className,animationCompleted,options.to)},addClass:function(element,className,animationCompleted,options){return options=options||{},animateAfter("addClass",element,suffixClasses(className,"-add"),animationCompleted,options.to)},removeClass:function(element,className,animationCompleted,options){return options=options||{},animateAfter("removeClass",element,suffixClasses(className,"-remove"),animationCompleted,options.to)}}}])}])}(window,window.angular),/*
 angular-dynamic-layout 2016-02-10 
*/
!function(){"use strict";angular.module("dynamicLayout",["ngAnimate"])}(),function(){"use strict";function dynamicLayout($timeout,$window,$q,$animate,PositionService){function link(scope,element){function onResize(){scope.$apply(function(){layout()})}function layout(){return PositionService.layout(element[0].offsetWidth)}function itemsLoaded(){var def=$q.defer();return $timeout(function(){0===scope.templatesToLoad&&def.resolve()}),scope.$watch("templatesToLoad",function(newValue,oldValue){newValue!==oldValue&&0===scope.templatesToLoad&&def.resolve()}),def.promise}function externalScope(){return scope.$parent}scope.templatesToLoad=0,scope.externalScope=externalScope,scope.$on("$includeContentRequested",function(){scope.templatesToLoad++}),scope.$on("$includeContentLoaded",function(){scope.templatesToLoad--}),scope.$watch("filteredItems",function(newValue,oldValue){scope.$parent.filteredItems=scope.filteredItems,angular.equals(newValue,oldValue)||itemsLoaded().then(function(){layout()})},!0),angular.element($window).on("resize",onResize),scope.$on("dynamicLayout.layout",function(event,callback){layout().then(function(){angular.isFunction("function")&&callback()})}),itemsLoaded().then(function(){layout()}),scope.$on("$destroy",function(){angular.element($window).off("resize",onResize)})}return{restrict:"A",scope:{items:"=",rankers:"=",filters:"=",defaulttemplate:"=?"},template:'<div                                                         class="dynamic-layout-item-parent"                        ng-repeat="it in items |                                             customFilter: filters |                                   customRanker:rankers |                                    as:this:\'filteredItems\'"                     ng-include="it.template || defaulttemplate"                 ></div>',link:link}}angular.module("dynamicLayout").directive("dynamicLayout",["$timeout","$window","$q","$animate","PositionService",dynamicLayout])}(),function(){"use strict";function layoutOnLoad($rootScope,$timeout){return{restrict:"A",link:function(scope,element){element.bind("load error",function(){var timeoutId;$timeout.cancel(timeoutId),timeoutId=$timeout(function(){$rootScope.$broadcast("dynamicLayout.layout")})})}}}angular.module("dynamicLayout").directive("layoutOnLoad",["$rootScope","$timeout",layoutOnLoad])}(),function(){"use strict";function FilterService(){function applyFilters(items,filters){var i,retItems=[];for(i in items)checkAndGroup(items[i],filters)&&retItems.push(items[i]);return retItems}function checkStatement(item,statement){if(angular.isFunction(statement))return statement(item);var STATEMENT_LENGTH=3;if(statement.length<STATEMENT_LENGTH)throw"Incorrect statement";var property=statement[0],comparator=statement[1],value=statement[2];if(!item[property])return!1;switch(comparator){case"=":return item[property]===value;case"<":return item[property]<value;case"<=":return item[property]<=value;case">":return item[property]>value;case">=":return item[property]>=value;case"!=":return item[property]!==value;case"in":return item[property]in value;case"not in":return!(item[property]in value);case"contains":if(!(item[property]instanceof Array))throw"contains statement has to be applied on array";return item[property].indexOf(value)>-1;default:throw"Incorrect statement comparator: "+comparator}}function checkOrGroup(item,orGroup){var j;for(j in orGroup)if(checkStatement(item,orGroup[j]))return!0;return!1}function checkAndGroup(item,andGroup){var i;for(i in andGroup)if(!checkOrGroup(item,andGroup[i]))return!1;return!0}return{applyFilters:applyFilters}}angular.module("dynamicLayout").factory("FilterService",FilterService)}(),function(){"use strict";function PositionService($window,$document,$animate,$timeout,$q){function getItemsDimensionFromDOM(){elements=$document[0].querySelectorAll(".dynamic-layout-item-parent:not(.ng-leave)"),items=[];for(var i=0;i<elements.length;++i){var width,height,rect=elements[i].children[0].getBoundingClientRect();rect.width?(width=rect.width,height=rect.height):(width=rect.right-rect.left,height=rect.top-rect.bottom),items.push({height:height+parseFloat($window.getComputedStyle(elements[i]).marginTop),width:width+parseFloat($window.getComputedStyle(elements[i].children[0]).marginLeft)})}return items}function applyToDOM(){function launchAnimation(element,i){var animationPromise=$animate.addClass(element,"move-items-animation",{from:{position:"absolute"},to:{left:items[i].x+"px",top:items[i].y+"px"}});return animationPromise.then(function(){element.classList.remove("move-items-animation"),delete ongoingAnimations[i]}),animationPromise}function launchAnimations(){var i;for(i=0;i<items.length;++i)ongoingAnimations[i]=launchAnimation(elements[i],i);$q.all(ongoingAnimations).then(function(){ret.resolve()})}var ret=$q.defer();if(Object.keys(ongoingAnimations).length)for(var j in ongoingAnimations)$animate.cancel(ongoingAnimations[j]),delete ongoingAnimations[j];var columnHeights=getColumnsHeights(columns);return angular.element("[dynamic-layout]").css("height",Math.max.apply(null,columnHeights)),$timeout(function(){launchAnimations(ret)}),ret.promise}function layout(containerWidth){items=self.getItemsDimensionFromDOM();var colSize=getColSize(),nbColumns=Math.floor(containerWidth/colSize);return initColumns(nbColumns),setItemsColumnSpan(colSize),setItemsPosition(columns,colSize),self.applyToDOM()}function getColumns(){return columns}function initColumns(nb){columns=[];var i;for(i=0;nb>i;++i)columns.push([]);return columns}function getColumnsHeights(cols){var i,columnsHeights=[];for(i in cols){var h;if(cols[i].length){var lastItem=cols[i][cols[i].length-1];h=lastItem.y+lastItem.height}else h=0;columnsHeights.push(h)}return columnsHeights}function getItemColumnsAndPosition(item,colHeights,colSize){if(item.columnSpan>colHeights.length)throw"Item too large";var i,indexOfMin=0,minFound=0;for(i=0;i<=colHeights.length-item.columnSpan;++i){var startingColumn=i,endingColumn=i+item.columnSpan,maxHeightInPart=Math.max.apply(Math,colHeights.slice(startingColumn,endingColumn));(0===i||minFound>maxHeightInPart)&&(minFound=maxHeightInPart,indexOfMin=i)}var itemColumns=[];for(i=indexOfMin;i<indexOfMin+item.columnSpan;++i)itemColumns.push(i);var position={x:itemColumns[0]*colSize,y:minFound};return{columns:itemColumns,position:position}}function setItemsPosition(cols,colSize){var i,j;for(i=0;i<items.length;++i){var columnsHeights=getColumnsHeights(cols),itemColumnsAndPosition=getItemColumnsAndPosition(items[i],columnsHeights,colSize);for(j in itemColumnsAndPosition.columns)columns[itemColumnsAndPosition.columns[j]].push(items[i]);items[i].x=itemColumnsAndPosition.position.x,items[i].y=itemColumnsAndPosition.position.y}}function getColSize(){var colSize,i;for(i=0;i<items.length;++i)(!colSize||items[i].width<colSize)&&(colSize=items[i].width);return colSize}function setItemsColumnSpan(colSize){var i;for(i=0;i<items.length;++i)items[i].columnSpan=Math.ceil(items[i].width/colSize)}var ongoingAnimations={},items=[],elements=[],columns=[],self={getItemsDimensionFromDOM:getItemsDimensionFromDOM,applyToDOM:applyToDOM,layout:layout,getColumns:getColumns};return self}angular.module("dynamicLayout").factory("PositionService",["$window","$document","$animate","$timeout","$q",PositionService])}(),function(){"use strict";function RankerService(){function applyRankers(items,rankers){function sorter(a,b){return i=0,recursiveRanker(a,b)}function recursiveRanker(a,b){var valueA,valueB,ranker=rankers[i][0],ascDesc=rankers[i][1];if(angular.isFunction(ranker))valueA=ranker(a),valueB=ranker(b);else{if(ranker in a||ranker in b){if(!(ranker in a))return"asc"===ascDesc?-1:1;if(!(ranker in b))return"asc"===ascDesc?1:-1}else valueA=0,valueB=0;valueA=a[ranker],valueB=b[ranker]}if(typeof valueA==typeof valueB)if(angular.isString(valueA)){var comp=valueA.localeCompare(valueB);if(1===comp)return"asc"===ascDesc?1:-1;if(-1===comp)return"asc"===ascDesc?-1:1}else{if(valueA>valueB)return"asc"===ascDesc?1:-1;if(valueB>valueA)return"asc"===ascDesc?-1:1}return++i,rankers.length>i?recursiveRanker(a,b):0}var i=0;return rankers&&items.sort(sorter),items}return{applyRankers:applyRankers}}angular.module("dynamicLayout").factory("RankerService",RankerService)}(),function(){"use strict";function as($parse){return function(value,context,path){return $parse(path).assign(context,value),value}}angular.module("dynamicLayout").filter("as",["$parse",as])}(),function(){"use strict";function customFilter(FilterService){return function(items,filters){return filters?FilterService.applyFilters(items,filters):items}}angular.module("dynamicLayout").filter("customFilter",["FilterService",customFilter])}(),function(){"use strict";function customRanker(RankerService){return function(items,rankers){return rankers?RankerService.applyRankers(items,rankers):items}}angular.module("dynamicLayout").filter("customRanker",["RankerService",customRanker])}();